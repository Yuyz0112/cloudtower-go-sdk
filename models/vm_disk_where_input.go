// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// VMDiskWhereInput Vm disk where input
//
// swagger:model VmDiskWhereInput
type VMDiskWhereInput struct {

	// a n d
	AND []*VMDiskWhereInput `json:"AND,omitempty"`

	// n o t
	NOT []*VMDiskWhereInput `json:"NOT,omitempty"`

	// o r
	OR []*VMDiskWhereInput `json:"OR,omitempty"`

	// boot
	Boot *float64 `json:"boot,omitempty"`

	// boot gt
	BootGt *float64 `json:"boot_gt,omitempty"`

	// boot gte
	BootGte *float64 `json:"boot_gte,omitempty"`

	// boot in
	BootIn []float64 `json:"boot_in,omitempty"`

	// boot lt
	BootLt *float64 `json:"boot_lt,omitempty"`

	// boot lte
	BootLte *float64 `json:"boot_lte,omitempty"`

	// boot not
	BootNot *float64 `json:"boot_not,omitempty"`

	// boot not in
	BootNotIn []float64 `json:"boot_not_in,omitempty"`

	// bus
	Bus interface{} `json:"bus,omitempty"`

	// bus in
	BusIn []Bus `json:"bus_in,omitempty"`

	// bus not
	BusNot interface{} `json:"bus_not,omitempty"`

	// bus not in
	BusNotIn []Bus `json:"bus_not_in,omitempty"`

	// cloud init image name
	CloudInitImageName *string `json:"cloud_init_image_name,omitempty"`

	// cloud init image name contains
	CloudInitImageNameContains *string `json:"cloud_init_image_name_contains,omitempty"`

	// cloud init image name ends with
	CloudInitImageNameEndsWith *string `json:"cloud_init_image_name_ends_with,omitempty"`

	// cloud init image name gt
	CloudInitImageNameGt *string `json:"cloud_init_image_name_gt,omitempty"`

	// cloud init image name gte
	CloudInitImageNameGte *string `json:"cloud_init_image_name_gte,omitempty"`

	// cloud init image name in
	CloudInitImageNameIn []string `json:"cloud_init_image_name_in,omitempty"`

	// cloud init image name lt
	CloudInitImageNameLt *string `json:"cloud_init_image_name_lt,omitempty"`

	// cloud init image name lte
	CloudInitImageNameLte *string `json:"cloud_init_image_name_lte,omitempty"`

	// cloud init image name not
	CloudInitImageNameNot *string `json:"cloud_init_image_name_not,omitempty"`

	// cloud init image name not contains
	CloudInitImageNameNotContains *string `json:"cloud_init_image_name_not_contains,omitempty"`

	// cloud init image name not ends with
	CloudInitImageNameNotEndsWith *string `json:"cloud_init_image_name_not_ends_with,omitempty"`

	// cloud init image name not in
	CloudInitImageNameNotIn []string `json:"cloud_init_image_name_not_in,omitempty"`

	// cloud init image name not starts with
	CloudInitImageNameNotStartsWith *string `json:"cloud_init_image_name_not_starts_with,omitempty"`

	// cloud init image name starts with
	CloudInitImageNameStartsWith *string `json:"cloud_init_image_name_starts_with,omitempty"`

	// cloud init image path
	CloudInitImagePath *string `json:"cloud_init_image_path,omitempty"`

	// cloud init image path contains
	CloudInitImagePathContains *string `json:"cloud_init_image_path_contains,omitempty"`

	// cloud init image path ends with
	CloudInitImagePathEndsWith *string `json:"cloud_init_image_path_ends_with,omitempty"`

	// cloud init image path gt
	CloudInitImagePathGt *string `json:"cloud_init_image_path_gt,omitempty"`

	// cloud init image path gte
	CloudInitImagePathGte *string `json:"cloud_init_image_path_gte,omitempty"`

	// cloud init image path in
	CloudInitImagePathIn []string `json:"cloud_init_image_path_in,omitempty"`

	// cloud init image path lt
	CloudInitImagePathLt *string `json:"cloud_init_image_path_lt,omitempty"`

	// cloud init image path lte
	CloudInitImagePathLte *string `json:"cloud_init_image_path_lte,omitempty"`

	// cloud init image path not
	CloudInitImagePathNot *string `json:"cloud_init_image_path_not,omitempty"`

	// cloud init image path not contains
	CloudInitImagePathNotContains *string `json:"cloud_init_image_path_not_contains,omitempty"`

	// cloud init image path not ends with
	CloudInitImagePathNotEndsWith *string `json:"cloud_init_image_path_not_ends_with,omitempty"`

	// cloud init image path not in
	CloudInitImagePathNotIn []string `json:"cloud_init_image_path_not_in,omitempty"`

	// cloud init image path not starts with
	CloudInitImagePathNotStartsWith *string `json:"cloud_init_image_path_not_starts_with,omitempty"`

	// cloud init image path starts with
	CloudInitImagePathStartsWith *string `json:"cloud_init_image_path_starts_with,omitempty"`

	// device
	Device *string `json:"device,omitempty"`

	// device contains
	DeviceContains *string `json:"device_contains,omitempty"`

	// device ends with
	DeviceEndsWith *string `json:"device_ends_with,omitempty"`

	// device gt
	DeviceGt *string `json:"device_gt,omitempty"`

	// device gte
	DeviceGte *string `json:"device_gte,omitempty"`

	// device in
	DeviceIn []string `json:"device_in,omitempty"`

	// device lt
	DeviceLt *string `json:"device_lt,omitempty"`

	// device lte
	DeviceLte *string `json:"device_lte,omitempty"`

	// device not
	DeviceNot *string `json:"device_not,omitempty"`

	// device not contains
	DeviceNotContains *string `json:"device_not_contains,omitempty"`

	// device not ends with
	DeviceNotEndsWith *string `json:"device_not_ends_with,omitempty"`

	// device not in
	DeviceNotIn []string `json:"device_not_in,omitempty"`

	// device not starts with
	DeviceNotStartsWith *string `json:"device_not_starts_with,omitempty"`

	// device starts with
	DeviceStartsWith *string `json:"device_starts_with,omitempty"`

	// disabled
	Disabled *bool `json:"disabled,omitempty"`

	// disabled not
	DisabledNot *bool `json:"disabled_not,omitempty"`

	// elf image
	ElfImage interface{} `json:"elf_image,omitempty"`

	// id
	ID *string `json:"id,omitempty"`

	// id contains
	IDContains *string `json:"id_contains,omitempty"`

	// id ends with
	IDEndsWith *string `json:"id_ends_with,omitempty"`

	// id gt
	IDGt *string `json:"id_gt,omitempty"`

	// id gte
	IDGte *string `json:"id_gte,omitempty"`

	// id in
	IDIn []string `json:"id_in,omitempty"`

	// id lt
	IDLt *string `json:"id_lt,omitempty"`

	// id lte
	IDLte *string `json:"id_lte,omitempty"`

	// id not
	IDNot *string `json:"id_not,omitempty"`

	// id not contains
	IDNotContains *string `json:"id_not_contains,omitempty"`

	// id not ends with
	IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`

	// id not in
	IDNotIn []string `json:"id_not_in,omitempty"`

	// id not starts with
	IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`

	// id starts with
	IDStartsWith *string `json:"id_starts_with,omitempty"`

	// key
	Key *float64 `json:"key,omitempty"`

	// key gt
	KeyGt *float64 `json:"key_gt,omitempty"`

	// key gte
	KeyGte *float64 `json:"key_gte,omitempty"`

	// key in
	KeyIn []float64 `json:"key_in,omitempty"`

	// key lt
	KeyLt *float64 `json:"key_lt,omitempty"`

	// key lte
	KeyLte *float64 `json:"key_lte,omitempty"`

	// key not
	KeyNot *float64 `json:"key_not,omitempty"`

	// key not in
	KeyNotIn []float64 `json:"key_not_in,omitempty"`

	// max bandwidth
	MaxBandwidth *float64 `json:"max_bandwidth,omitempty"`

	// max bandwidth gt
	MaxBandwidthGt *float64 `json:"max_bandwidth_gt,omitempty"`

	// max bandwidth gte
	MaxBandwidthGte *float64 `json:"max_bandwidth_gte,omitempty"`

	// max bandwidth in
	MaxBandwidthIn []float64 `json:"max_bandwidth_in,omitempty"`

	// max bandwidth lt
	MaxBandwidthLt *float64 `json:"max_bandwidth_lt,omitempty"`

	// max bandwidth lte
	MaxBandwidthLte *float64 `json:"max_bandwidth_lte,omitempty"`

	// max bandwidth not
	MaxBandwidthNot *float64 `json:"max_bandwidth_not,omitempty"`

	// max bandwidth not in
	MaxBandwidthNotIn []float64 `json:"max_bandwidth_not_in,omitempty"`

	// max bandwidth policy
	MaxBandwidthPolicy interface{} `json:"max_bandwidth_policy,omitempty"`

	// max bandwidth policy in
	MaxBandwidthPolicyIn []VMDiskIoRestrictType `json:"max_bandwidth_policy_in,omitempty"`

	// max bandwidth policy not
	MaxBandwidthPolicyNot interface{} `json:"max_bandwidth_policy_not,omitempty"`

	// max bandwidth policy not in
	MaxBandwidthPolicyNotIn []VMDiskIoRestrictType `json:"max_bandwidth_policy_not_in,omitempty"`

	// max iops
	MaxIops *float64 `json:"max_iops,omitempty"`

	// max iops gt
	MaxIopsGt *float64 `json:"max_iops_gt,omitempty"`

	// max iops gte
	MaxIopsGte *float64 `json:"max_iops_gte,omitempty"`

	// max iops in
	MaxIopsIn []float64 `json:"max_iops_in,omitempty"`

	// max iops lt
	MaxIopsLt *float64 `json:"max_iops_lt,omitempty"`

	// max iops lte
	MaxIopsLte *float64 `json:"max_iops_lte,omitempty"`

	// max iops not
	MaxIopsNot *float64 `json:"max_iops_not,omitempty"`

	// max iops not in
	MaxIopsNotIn []float64 `json:"max_iops_not_in,omitempty"`

	// max iops policy
	MaxIopsPolicy interface{} `json:"max_iops_policy,omitempty"`

	// max iops policy in
	MaxIopsPolicyIn []VMDiskIoRestrictType `json:"max_iops_policy_in,omitempty"`

	// max iops policy not
	MaxIopsPolicyNot interface{} `json:"max_iops_policy_not,omitempty"`

	// max iops policy not in
	MaxIopsPolicyNotIn []VMDiskIoRestrictType `json:"max_iops_policy_not_in,omitempty"`

	// serial
	Serial *string `json:"serial,omitempty"`

	// serial contains
	SerialContains *string `json:"serial_contains,omitempty"`

	// serial ends with
	SerialEndsWith *string `json:"serial_ends_with,omitempty"`

	// serial gt
	SerialGt *string `json:"serial_gt,omitempty"`

	// serial gte
	SerialGte *string `json:"serial_gte,omitempty"`

	// serial in
	SerialIn []string `json:"serial_in,omitempty"`

	// serial lt
	SerialLt *string `json:"serial_lt,omitempty"`

	// serial lte
	SerialLte *string `json:"serial_lte,omitempty"`

	// serial not
	SerialNot *string `json:"serial_not,omitempty"`

	// serial not contains
	SerialNotContains *string `json:"serial_not_contains,omitempty"`

	// serial not ends with
	SerialNotEndsWith *string `json:"serial_not_ends_with,omitempty"`

	// serial not in
	SerialNotIn []string `json:"serial_not_in,omitempty"`

	// serial not starts with
	SerialNotStartsWith *string `json:"serial_not_starts_with,omitempty"`

	// serial starts with
	SerialStartsWith *string `json:"serial_starts_with,omitempty"`

	// svt image
	SvtImage interface{} `json:"svt_image,omitempty"`

	// type
	Type interface{} `json:"type,omitempty"`

	// type in
	TypeIn []VMDiskType `json:"type_in,omitempty"`

	// type not
	TypeNot interface{} `json:"type_not,omitempty"`

	// type not in
	TypeNotIn []VMDiskType `json:"type_not_in,omitempty"`

	// unsafe image path
	UnsafeImagePath *string `json:"unsafe_image_path,omitempty"`

	// unsafe image path contains
	UnsafeImagePathContains *string `json:"unsafe_image_path_contains,omitempty"`

	// unsafe image path ends with
	UnsafeImagePathEndsWith *string `json:"unsafe_image_path_ends_with,omitempty"`

	// unsafe image path gt
	UnsafeImagePathGt *string `json:"unsafe_image_path_gt,omitempty"`

	// unsafe image path gte
	UnsafeImagePathGte *string `json:"unsafe_image_path_gte,omitempty"`

	// unsafe image path in
	UnsafeImagePathIn []string `json:"unsafe_image_path_in,omitempty"`

	// unsafe image path lt
	UnsafeImagePathLt *string `json:"unsafe_image_path_lt,omitempty"`

	// unsafe image path lte
	UnsafeImagePathLte *string `json:"unsafe_image_path_lte,omitempty"`

	// unsafe image path not
	UnsafeImagePathNot *string `json:"unsafe_image_path_not,omitempty"`

	// unsafe image path not contains
	UnsafeImagePathNotContains *string `json:"unsafe_image_path_not_contains,omitempty"`

	// unsafe image path not ends with
	UnsafeImagePathNotEndsWith *string `json:"unsafe_image_path_not_ends_with,omitempty"`

	// unsafe image path not in
	UnsafeImagePathNotIn []string `json:"unsafe_image_path_not_in,omitempty"`

	// unsafe image path not starts with
	UnsafeImagePathNotStartsWith *string `json:"unsafe_image_path_not_starts_with,omitempty"`

	// unsafe image path starts with
	UnsafeImagePathStartsWith *string `json:"unsafe_image_path_starts_with,omitempty"`

	// unsafe image uuid
	UnsafeImageUUID *string `json:"unsafe_image_uuid,omitempty"`

	// unsafe image uuid contains
	UnsafeImageUUIDContains *string `json:"unsafe_image_uuid_contains,omitempty"`

	// unsafe image uuid ends with
	UnsafeImageUUIDEndsWith *string `json:"unsafe_image_uuid_ends_with,omitempty"`

	// unsafe image uuid gt
	UnsafeImageUUIDGt *string `json:"unsafe_image_uuid_gt,omitempty"`

	// unsafe image uuid gte
	UnsafeImageUUIDGte *string `json:"unsafe_image_uuid_gte,omitempty"`

	// unsafe image uuid in
	UnsafeImageUUIDIn []string `json:"unsafe_image_uuid_in,omitempty"`

	// unsafe image uuid lt
	UnsafeImageUUIDLt *string `json:"unsafe_image_uuid_lt,omitempty"`

	// unsafe image uuid lte
	UnsafeImageUUIDLte *string `json:"unsafe_image_uuid_lte,omitempty"`

	// unsafe image uuid not
	UnsafeImageUUIDNot *string `json:"unsafe_image_uuid_not,omitempty"`

	// unsafe image uuid not contains
	UnsafeImageUUIDNotContains *string `json:"unsafe_image_uuid_not_contains,omitempty"`

	// unsafe image uuid not ends with
	UnsafeImageUUIDNotEndsWith *string `json:"unsafe_image_uuid_not_ends_with,omitempty"`

	// unsafe image uuid not in
	UnsafeImageUUIDNotIn []string `json:"unsafe_image_uuid_not_in,omitempty"`

	// unsafe image uuid not starts with
	UnsafeImageUUIDNotStartsWith *string `json:"unsafe_image_uuid_not_starts_with,omitempty"`

	// unsafe image uuid starts with
	UnsafeImageUUIDStartsWith *string `json:"unsafe_image_uuid_starts_with,omitempty"`

	// unsafe provision
	UnsafeProvision *string `json:"unsafe_provision,omitempty"`

	// unsafe provision contains
	UnsafeProvisionContains *string `json:"unsafe_provision_contains,omitempty"`

	// unsafe provision ends with
	UnsafeProvisionEndsWith *string `json:"unsafe_provision_ends_with,omitempty"`

	// unsafe provision gt
	UnsafeProvisionGt *string `json:"unsafe_provision_gt,omitempty"`

	// unsafe provision gte
	UnsafeProvisionGte *string `json:"unsafe_provision_gte,omitempty"`

	// unsafe provision in
	UnsafeProvisionIn []string `json:"unsafe_provision_in,omitempty"`

	// unsafe provision lt
	UnsafeProvisionLt *string `json:"unsafe_provision_lt,omitempty"`

	// unsafe provision lte
	UnsafeProvisionLte *string `json:"unsafe_provision_lte,omitempty"`

	// unsafe provision not
	UnsafeProvisionNot *string `json:"unsafe_provision_not,omitempty"`

	// unsafe provision not contains
	UnsafeProvisionNotContains *string `json:"unsafe_provision_not_contains,omitempty"`

	// unsafe provision not ends with
	UnsafeProvisionNotEndsWith *string `json:"unsafe_provision_not_ends_with,omitempty"`

	// unsafe provision not in
	UnsafeProvisionNotIn []string `json:"unsafe_provision_not_in,omitempty"`

	// unsafe provision not starts with
	UnsafeProvisionNotStartsWith *string `json:"unsafe_provision_not_starts_with,omitempty"`

	// unsafe provision starts with
	UnsafeProvisionStartsWith *string `json:"unsafe_provision_starts_with,omitempty"`

	// vm
	VM interface{} `json:"vm,omitempty"`

	// vm volume
	VMVolume interface{} `json:"vm_volume,omitempty"`
}

// Validate validates this Vm disk where input
func (m *VMDiskWhereInput) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAND(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNOT(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOR(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBusIn(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBusNotIn(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMaxBandwidthPolicyIn(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMaxBandwidthPolicyNotIn(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMaxIopsPolicyIn(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMaxIopsPolicyNotIn(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTypeIn(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTypeNotIn(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VMDiskWhereInput) validateAND(formats strfmt.Registry) error {
	if swag.IsZero(m.AND) { // not required
		return nil
	}

	for i := 0; i < len(m.AND); i++ {
		if swag.IsZero(m.AND[i]) { // not required
			continue
		}

		if m.AND[i] != nil {
			if err := m.AND[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("AND" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VMDiskWhereInput) validateNOT(formats strfmt.Registry) error {
	if swag.IsZero(m.NOT) { // not required
		return nil
	}

	for i := 0; i < len(m.NOT); i++ {
		if swag.IsZero(m.NOT[i]) { // not required
			continue
		}

		if m.NOT[i] != nil {
			if err := m.NOT[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("NOT" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VMDiskWhereInput) validateOR(formats strfmt.Registry) error {
	if swag.IsZero(m.OR) { // not required
		return nil
	}

	for i := 0; i < len(m.OR); i++ {
		if swag.IsZero(m.OR[i]) { // not required
			continue
		}

		if m.OR[i] != nil {
			if err := m.OR[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("OR" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VMDiskWhereInput) validateBusIn(formats strfmt.Registry) error {
	if swag.IsZero(m.BusIn) { // not required
		return nil
	}

	for i := 0; i < len(m.BusIn); i++ {

		if err := m.BusIn[i].Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("bus_in" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *VMDiskWhereInput) validateBusNotIn(formats strfmt.Registry) error {
	if swag.IsZero(m.BusNotIn) { // not required
		return nil
	}

	for i := 0; i < len(m.BusNotIn); i++ {

		if err := m.BusNotIn[i].Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("bus_not_in" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *VMDiskWhereInput) validateMaxBandwidthPolicyIn(formats strfmt.Registry) error {
	if swag.IsZero(m.MaxBandwidthPolicyIn) { // not required
		return nil
	}

	for i := 0; i < len(m.MaxBandwidthPolicyIn); i++ {

		if err := m.MaxBandwidthPolicyIn[i].Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("max_bandwidth_policy_in" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *VMDiskWhereInput) validateMaxBandwidthPolicyNotIn(formats strfmt.Registry) error {
	if swag.IsZero(m.MaxBandwidthPolicyNotIn) { // not required
		return nil
	}

	for i := 0; i < len(m.MaxBandwidthPolicyNotIn); i++ {

		if err := m.MaxBandwidthPolicyNotIn[i].Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("max_bandwidth_policy_not_in" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *VMDiskWhereInput) validateMaxIopsPolicyIn(formats strfmt.Registry) error {
	if swag.IsZero(m.MaxIopsPolicyIn) { // not required
		return nil
	}

	for i := 0; i < len(m.MaxIopsPolicyIn); i++ {

		if err := m.MaxIopsPolicyIn[i].Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("max_iops_policy_in" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *VMDiskWhereInput) validateMaxIopsPolicyNotIn(formats strfmt.Registry) error {
	if swag.IsZero(m.MaxIopsPolicyNotIn) { // not required
		return nil
	}

	for i := 0; i < len(m.MaxIopsPolicyNotIn); i++ {

		if err := m.MaxIopsPolicyNotIn[i].Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("max_iops_policy_not_in" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *VMDiskWhereInput) validateTypeIn(formats strfmt.Registry) error {
	if swag.IsZero(m.TypeIn) { // not required
		return nil
	}

	for i := 0; i < len(m.TypeIn); i++ {

		if err := m.TypeIn[i].Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("type_in" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *VMDiskWhereInput) validateTypeNotIn(formats strfmt.Registry) error {
	if swag.IsZero(m.TypeNotIn) { // not required
		return nil
	}

	for i := 0; i < len(m.TypeNotIn); i++ {

		if err := m.TypeNotIn[i].Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("type_not_in" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

// ContextValidate validate this Vm disk where input based on the context it is used
func (m *VMDiskWhereInput) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAND(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNOT(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOR(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBusIn(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBusNotIn(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMaxBandwidthPolicyIn(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMaxBandwidthPolicyNotIn(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMaxIopsPolicyIn(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMaxIopsPolicyNotIn(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTypeIn(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTypeNotIn(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VMDiskWhereInput) contextValidateAND(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.AND); i++ {

		if m.AND[i] != nil {
			if err := m.AND[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("AND" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VMDiskWhereInput) contextValidateNOT(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.NOT); i++ {

		if m.NOT[i] != nil {
			if err := m.NOT[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("NOT" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VMDiskWhereInput) contextValidateOR(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.OR); i++ {

		if m.OR[i] != nil {
			if err := m.OR[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("OR" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VMDiskWhereInput) contextValidateBusIn(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.BusIn); i++ {

		if err := m.BusIn[i].ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("bus_in" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *VMDiskWhereInput) contextValidateBusNotIn(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.BusNotIn); i++ {

		if err := m.BusNotIn[i].ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("bus_not_in" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *VMDiskWhereInput) contextValidateMaxBandwidthPolicyIn(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.MaxBandwidthPolicyIn); i++ {

		if err := m.MaxBandwidthPolicyIn[i].ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("max_bandwidth_policy_in" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *VMDiskWhereInput) contextValidateMaxBandwidthPolicyNotIn(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.MaxBandwidthPolicyNotIn); i++ {

		if err := m.MaxBandwidthPolicyNotIn[i].ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("max_bandwidth_policy_not_in" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *VMDiskWhereInput) contextValidateMaxIopsPolicyIn(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.MaxIopsPolicyIn); i++ {

		if err := m.MaxIopsPolicyIn[i].ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("max_iops_policy_in" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *VMDiskWhereInput) contextValidateMaxIopsPolicyNotIn(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.MaxIopsPolicyNotIn); i++ {

		if err := m.MaxIopsPolicyNotIn[i].ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("max_iops_policy_not_in" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *VMDiskWhereInput) contextValidateTypeIn(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.TypeIn); i++ {

		if err := m.TypeIn[i].ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("type_in" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *VMDiskWhereInput) contextValidateTypeNotIn(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.TypeNotIn); i++ {

		if err := m.TypeNotIn[i].ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("type_not_in" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *VMDiskWhereInput) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VMDiskWhereInput) UnmarshalBinary(b []byte) error {
	var res VMDiskWhereInput
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
