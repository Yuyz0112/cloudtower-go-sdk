// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Cluster cluster
//
// swagger:model Cluster
type Cluster struct {

	// applications
	Applications []*NestedApplication `json:"applications,omitempty"`

	// architecture
	// Required: true
	Architecture *Architecture `json:"architecture"`

	// auto converge
	AutoConverge *bool `json:"auto_converge,omitempty"`

	// backup by service
	BackupByService *NestedBackupService `json:"backup_by_service,omitempty"`

	// connect state
	// Required: true
	ConnectState *ConnectState `json:"connect_state"`

	// consistency groups
	ConsistencyGroups []*NestedConsistencyGroup `json:"consistency_groups,omitempty"`

	// current cpu model
	CurrentCPUModel *string `json:"current_cpu_model,omitempty"`

	// datacenters
	Datacenters []*NestedDatacenter `json:"datacenters,omitempty"`

	// disconnected date
	DisconnectedDate *string `json:"disconnected_date,omitempty"`

	// disconnected reason
	DisconnectedReason *ClusterConnectorErrorCode `json:"disconnected_reason,omitempty"`

	// dns
	// Required: true
	DNS []string `json:"dns"`

	// entity async status
	EntityAsyncStatus *EntityAsyncStatus `json:"entityAsyncStatus,omitempty"`

	// everoute cluster
	EverouteCluster *NestedEverouteCluster `json:"everoute_cluster,omitempty"`

	// failure data space
	FailureDataSpace *float64 `json:"failure_data_space,omitempty"`

	// has metrox
	HasMetrox *bool `json:"has_metrox,omitempty"`

	// has remote backup
	HasRemoteBackup *bool `json:"has_remote_backup,omitempty"`

	// host num
	HostNum *int32 `json:"host_num,omitempty"`

	// hosts
	Hosts []*NestedHost `json:"hosts,omitempty"`

	// hypervisor
	Hypervisor *Hypervisor `json:"hypervisor,omitempty"`

	// id
	// Required: true
	ID *string `json:"id"`

	// ip
	// Required: true
	IP *string `json:"ip"`

	// is all flash
	IsAllFlash *bool `json:"is_all_flash,omitempty"`

	// iscsi vip
	IscsiVip *string `json:"iscsi_vip,omitempty"`

	// labels
	Labels []*NestedLabel `json:"labels,omitempty"`

	// license expire date
	LicenseExpireDate *string `json:"license_expire_date,omitempty"`

	// license serial
	LicenseSerial *string `json:"license_serial,omitempty"`

	// license sign date
	LicenseSignDate *string `json:"license_sign_date,omitempty"`

	// license type
	LicenseType *LicenseType `json:"license_type,omitempty"`

	// local id
	LocalID *string `json:"local_id,omitempty"`

	// maintenance end date
	MaintenanceEndDate *string `json:"maintenance_end_date,omitempty"`

	// maintenance start date
	MaintenanceStartDate *string `json:"maintenance_start_date,omitempty"`

	// management vip
	ManagementVip *string `json:"management_vip,omitempty"`

	// max chunk num
	MaxChunkNum *int32 `json:"max_chunk_num,omitempty"`

	// max physical data capacity
	MaxPhysicalDataCapacity *float64 `json:"max_physical_data_capacity,omitempty"`

	// max physical data capacity per node
	MaxPhysicalDataCapacityPerNode *float64 `json:"max_physical_data_capacity_per_node,omitempty"`

	// metro availability checklist
	MetroAvailabilityChecklist *NestedMetroAvailabilityChecklist `json:"metro_availability_checklist,omitempty"`

	// mgt gateway
	MgtGateway *string `json:"mgt_gateway,omitempty"`

	// mgt netmask
	MgtNetmask *string `json:"mgt_netmask,omitempty"`

	// migration data size
	MigrationDataSize *float64 `json:"migration_data_size,omitempty"`

	// migration speed
	MigrationSpeed *float64 `json:"migration_speed,omitempty"`

	// name
	// Required: true
	Name *string `json:"name"`

	// ntp mode
	NtpMode *NtpMode `json:"ntp_mode,omitempty"`

	// ntp servers
	// Required: true
	NtpServers []string `json:"ntp_servers"`

	// nvmf enabled
	NvmfEnabled *bool `json:"nvmf_enabled,omitempty"`

	// pmem enabled
	PmemEnabled *bool `json:"pmem_enabled,omitempty"`

	// provisioned cpu cores
	ProvisionedCPUCores *int32 `json:"provisioned_cpu_cores,omitempty"`

	// provisioned cpu cores for active vm
	ProvisionedCPUCoresForActiveVM *int32 `json:"provisioned_cpu_cores_for_active_vm,omitempty"`

	// provisioned for active vm ratio
	ProvisionedForActiveVMRatio *float64 `json:"provisioned_for_active_vm_ratio,omitempty"`

	// provisioned memory bytes
	ProvisionedMemoryBytes *float64 `json:"provisioned_memory_bytes,omitempty"`

	// provisioned ratio
	ProvisionedRatio *float64 `json:"provisioned_ratio,omitempty"`

	// rdma enabled
	RdmaEnabled *bool `json:"rdma_enabled,omitempty"`

	// recommended cpu models
	// Required: true
	RecommendedCPUModels []string `json:"recommended_cpu_models"`

	// recover data size
	RecoverDataSize *float64 `json:"recover_data_size,omitempty"`

	// recover speed
	RecoverSpeed *float64 `json:"recover_speed,omitempty"`

	// reserved cpu cores for system service
	ReservedCPUCoresForSystemService *int32 `json:"reserved_cpu_cores_for_system_service,omitempty"`

	// running vm num
	RunningVMNum *int32 `json:"running_vm_num,omitempty"`

	// settings
	Settings *NestedClusterSettings `json:"settings,omitempty"`

	// software edition
	SoftwareEdition *SoftwareEdition `json:"software_edition,omitempty"`

	// stopped vm num
	StoppedVMNum *int32 `json:"stopped_vm_num,omitempty"`

	// stretch
	Stretch *bool `json:"stretch,omitempty"`

	// suspended vm num
	SuspendedVMNum *int32 `json:"suspended_vm_num,omitempty"`

	// total cache capacity
	TotalCacheCapacity *float64 `json:"total_cache_capacity,omitempty"`

	// total cpu cores
	TotalCPUCores *int32 `json:"total_cpu_cores,omitempty"`

	// total cpu hz
	TotalCPUHz *float64 `json:"total_cpu_hz,omitempty"`

	// total cpu models
	// Required: true
	TotalCPUModels []string `json:"total_cpu_models"`

	// total cpu sockets
	TotalCPUSockets *int32 `json:"total_cpu_sockets,omitempty"`

	// total data capacity
	TotalDataCapacity *float64 `json:"total_data_capacity,omitempty"`

	// total memory bytes
	TotalMemoryBytes *float64 `json:"total_memory_bytes,omitempty"`

	// type
	// Required: true
	Type *ClusterType `json:"type"`

	// upgrade tool version
	UpgradeToolVersion *string `json:"upgrade_tool_version,omitempty"`

	// used cpu hz
	UsedCPUHz *float64 `json:"used_cpu_hz,omitempty"`

	// used data space
	UsedDataSpace *float64 `json:"used_data_space,omitempty"`

	// used memory bytes
	UsedMemoryBytes *float64 `json:"used_memory_bytes,omitempty"`

	// valid data space
	ValidDataSpace *float64 `json:"valid_data_space,omitempty"`

	// vcenter account
	VcenterAccount *NestedVcenterAccount `json:"vcenterAccount,omitempty"`

	// vdses
	Vdses []*NestedVds `json:"vdses,omitempty"`

	// version
	// Required: true
	Version *string `json:"version"`

	// vhost enabled
	VhostEnabled *bool `json:"vhost_enabled,omitempty"`

	// vm folders
	VMFolders []*NestedVMFolder `json:"vm_folders,omitempty"`

	// vm num
	VMNum *int32 `json:"vm_num,omitempty"`

	// vm templates
	VMTemplates []*NestedVMTemplate `json:"vm_templates,omitempty"`

	// vms
	Vms []*NestedVM `json:"vms,omitempty"`

	// witness
	Witness *NestedWitness `json:"witness,omitempty"`

	// zones
	Zones []*NestedZone `json:"zones,omitempty"`
}

// Validate validates this cluster
func (m *Cluster) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateApplications(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateArchitecture(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBackupByService(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConnectState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConsistencyGroups(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDatacenters(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDisconnectedReason(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDNS(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEntityAsyncStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEverouteCluster(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHosts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHypervisor(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIP(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLabels(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLicenseType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMetroAvailabilityChecklist(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNtpMode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNtpServers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRecommendedCPUModels(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSettings(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSoftwareEdition(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTotalCPUModels(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVcenterAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVdses(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVMFolders(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVMTemplates(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVms(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWitness(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateZones(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Cluster) validateApplications(formats strfmt.Registry) error {
	if swag.IsZero(m.Applications) { // not required
		return nil
	}

	for i := 0; i < len(m.Applications); i++ {
		if swag.IsZero(m.Applications[i]) { // not required
			continue
		}

		if m.Applications[i] != nil {
			if err := m.Applications[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("applications" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("applications" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Cluster) validateArchitecture(formats strfmt.Registry) error {

	if err := validate.Required("architecture", "body", m.Architecture); err != nil {
		return err
	}

	if err := validate.Required("architecture", "body", m.Architecture); err != nil {
		return err
	}

	if m.Architecture != nil {
		if err := m.Architecture.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("architecture")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("architecture")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateBackupByService(formats strfmt.Registry) error {
	if swag.IsZero(m.BackupByService) { // not required
		return nil
	}

	if m.BackupByService != nil {
		if err := m.BackupByService.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("backup_by_service")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("backup_by_service")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateConnectState(formats strfmt.Registry) error {

	if err := validate.Required("connect_state", "body", m.ConnectState); err != nil {
		return err
	}

	if err := validate.Required("connect_state", "body", m.ConnectState); err != nil {
		return err
	}

	if m.ConnectState != nil {
		if err := m.ConnectState.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("connect_state")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("connect_state")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateConsistencyGroups(formats strfmt.Registry) error {
	if swag.IsZero(m.ConsistencyGroups) { // not required
		return nil
	}

	for i := 0; i < len(m.ConsistencyGroups); i++ {
		if swag.IsZero(m.ConsistencyGroups[i]) { // not required
			continue
		}

		if m.ConsistencyGroups[i] != nil {
			if err := m.ConsistencyGroups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("consistency_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("consistency_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Cluster) validateDatacenters(formats strfmt.Registry) error {
	if swag.IsZero(m.Datacenters) { // not required
		return nil
	}

	for i := 0; i < len(m.Datacenters); i++ {
		if swag.IsZero(m.Datacenters[i]) { // not required
			continue
		}

		if m.Datacenters[i] != nil {
			if err := m.Datacenters[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("datacenters" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("datacenters" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Cluster) validateDisconnectedReason(formats strfmt.Registry) error {
	if swag.IsZero(m.DisconnectedReason) { // not required
		return nil
	}

	if m.DisconnectedReason != nil {
		if err := m.DisconnectedReason.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("disconnected_reason")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("disconnected_reason")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateDNS(formats strfmt.Registry) error {

	if err := validate.Required("dns", "body", m.DNS); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateEntityAsyncStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.EntityAsyncStatus) { // not required
		return nil
	}

	if m.EntityAsyncStatus != nil {
		if err := m.EntityAsyncStatus.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("entityAsyncStatus")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("entityAsyncStatus")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateEverouteCluster(formats strfmt.Registry) error {
	if swag.IsZero(m.EverouteCluster) { // not required
		return nil
	}

	if m.EverouteCluster != nil {
		if err := m.EverouteCluster.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("everoute_cluster")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("everoute_cluster")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateHosts(formats strfmt.Registry) error {
	if swag.IsZero(m.Hosts) { // not required
		return nil
	}

	for i := 0; i < len(m.Hosts); i++ {
		if swag.IsZero(m.Hosts[i]) { // not required
			continue
		}

		if m.Hosts[i] != nil {
			if err := m.Hosts[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("hosts" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("hosts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Cluster) validateHypervisor(formats strfmt.Registry) error {
	if swag.IsZero(m.Hypervisor) { // not required
		return nil
	}

	if m.Hypervisor != nil {
		if err := m.Hypervisor.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("hypervisor")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("hypervisor")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateIP(formats strfmt.Registry) error {

	if err := validate.Required("ip", "body", m.IP); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateLabels(formats strfmt.Registry) error {
	if swag.IsZero(m.Labels) { // not required
		return nil
	}

	for i := 0; i < len(m.Labels); i++ {
		if swag.IsZero(m.Labels[i]) { // not required
			continue
		}

		if m.Labels[i] != nil {
			if err := m.Labels[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("labels" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("labels" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Cluster) validateLicenseType(formats strfmt.Registry) error {
	if swag.IsZero(m.LicenseType) { // not required
		return nil
	}

	if m.LicenseType != nil {
		if err := m.LicenseType.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("license_type")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("license_type")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateMetroAvailabilityChecklist(formats strfmt.Registry) error {
	if swag.IsZero(m.MetroAvailabilityChecklist) { // not required
		return nil
	}

	if m.MetroAvailabilityChecklist != nil {
		if err := m.MetroAvailabilityChecklist.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metro_availability_checklist")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("metro_availability_checklist")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateNtpMode(formats strfmt.Registry) error {
	if swag.IsZero(m.NtpMode) { // not required
		return nil
	}

	if m.NtpMode != nil {
		if err := m.NtpMode.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ntp_mode")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ntp_mode")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateNtpServers(formats strfmt.Registry) error {

	if err := validate.Required("ntp_servers", "body", m.NtpServers); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateRecommendedCPUModels(formats strfmt.Registry) error {

	if err := validate.Required("recommended_cpu_models", "body", m.RecommendedCPUModels); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateSettings(formats strfmt.Registry) error {
	if swag.IsZero(m.Settings) { // not required
		return nil
	}

	if m.Settings != nil {
		if err := m.Settings.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("settings")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("settings")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateSoftwareEdition(formats strfmt.Registry) error {
	if swag.IsZero(m.SoftwareEdition) { // not required
		return nil
	}

	if m.SoftwareEdition != nil {
		if err := m.SoftwareEdition.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("software_edition")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("software_edition")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateTotalCPUModels(formats strfmt.Registry) error {

	if err := validate.Required("total_cpu_models", "body", m.TotalCPUModels); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateType(formats strfmt.Registry) error {

	if err := validate.Required("type", "body", m.Type); err != nil {
		return err
	}

	if err := validate.Required("type", "body", m.Type); err != nil {
		return err
	}

	if m.Type != nil {
		if err := m.Type.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("type")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("type")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateVcenterAccount(formats strfmt.Registry) error {
	if swag.IsZero(m.VcenterAccount) { // not required
		return nil
	}

	if m.VcenterAccount != nil {
		if err := m.VcenterAccount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vcenterAccount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("vcenterAccount")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateVdses(formats strfmt.Registry) error {
	if swag.IsZero(m.Vdses) { // not required
		return nil
	}

	for i := 0; i < len(m.Vdses); i++ {
		if swag.IsZero(m.Vdses[i]) { // not required
			continue
		}

		if m.Vdses[i] != nil {
			if err := m.Vdses[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("vdses" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("vdses" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Cluster) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version", "body", m.Version); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateVMFolders(formats strfmt.Registry) error {
	if swag.IsZero(m.VMFolders) { // not required
		return nil
	}

	for i := 0; i < len(m.VMFolders); i++ {
		if swag.IsZero(m.VMFolders[i]) { // not required
			continue
		}

		if m.VMFolders[i] != nil {
			if err := m.VMFolders[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("vm_folders" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("vm_folders" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Cluster) validateVMTemplates(formats strfmt.Registry) error {
	if swag.IsZero(m.VMTemplates) { // not required
		return nil
	}

	for i := 0; i < len(m.VMTemplates); i++ {
		if swag.IsZero(m.VMTemplates[i]) { // not required
			continue
		}

		if m.VMTemplates[i] != nil {
			if err := m.VMTemplates[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("vm_templates" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("vm_templates" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Cluster) validateVms(formats strfmt.Registry) error {
	if swag.IsZero(m.Vms) { // not required
		return nil
	}

	for i := 0; i < len(m.Vms); i++ {
		if swag.IsZero(m.Vms[i]) { // not required
			continue
		}

		if m.Vms[i] != nil {
			if err := m.Vms[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("vms" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("vms" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Cluster) validateWitness(formats strfmt.Registry) error {
	if swag.IsZero(m.Witness) { // not required
		return nil
	}

	if m.Witness != nil {
		if err := m.Witness.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("witness")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("witness")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateZones(formats strfmt.Registry) error {
	if swag.IsZero(m.Zones) { // not required
		return nil
	}

	for i := 0; i < len(m.Zones); i++ {
		if swag.IsZero(m.Zones[i]) { // not required
			continue
		}

		if m.Zones[i] != nil {
			if err := m.Zones[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("zones" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("zones" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this cluster based on the context it is used
func (m *Cluster) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateApplications(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateArchitecture(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBackupByService(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateConnectState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateConsistencyGroups(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDatacenters(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDisconnectedReason(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEntityAsyncStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEverouteCluster(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHosts(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHypervisor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLabels(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLicenseType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMetroAvailabilityChecklist(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNtpMode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSettings(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSoftwareEdition(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVcenterAccount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVdses(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVMFolders(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVMTemplates(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVms(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateWitness(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateZones(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Cluster) contextValidateApplications(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Applications); i++ {

		if m.Applications[i] != nil {
			if err := m.Applications[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("applications" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("applications" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Cluster) contextValidateArchitecture(ctx context.Context, formats strfmt.Registry) error {

	if m.Architecture != nil {
		if err := m.Architecture.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("architecture")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("architecture")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateBackupByService(ctx context.Context, formats strfmt.Registry) error {

	if m.BackupByService != nil {
		if err := m.BackupByService.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("backup_by_service")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("backup_by_service")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateConnectState(ctx context.Context, formats strfmt.Registry) error {

	if m.ConnectState != nil {
		if err := m.ConnectState.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("connect_state")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("connect_state")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateConsistencyGroups(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ConsistencyGroups); i++ {

		if m.ConsistencyGroups[i] != nil {
			if err := m.ConsistencyGroups[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("consistency_groups" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("consistency_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Cluster) contextValidateDatacenters(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Datacenters); i++ {

		if m.Datacenters[i] != nil {
			if err := m.Datacenters[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("datacenters" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("datacenters" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Cluster) contextValidateDisconnectedReason(ctx context.Context, formats strfmt.Registry) error {

	if m.DisconnectedReason != nil {
		if err := m.DisconnectedReason.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("disconnected_reason")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("disconnected_reason")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateEntityAsyncStatus(ctx context.Context, formats strfmt.Registry) error {

	if m.EntityAsyncStatus != nil {
		if err := m.EntityAsyncStatus.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("entityAsyncStatus")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("entityAsyncStatus")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateEverouteCluster(ctx context.Context, formats strfmt.Registry) error {

	if m.EverouteCluster != nil {
		if err := m.EverouteCluster.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("everoute_cluster")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("everoute_cluster")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateHosts(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Hosts); i++ {

		if m.Hosts[i] != nil {
			if err := m.Hosts[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("hosts" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("hosts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Cluster) contextValidateHypervisor(ctx context.Context, formats strfmt.Registry) error {

	if m.Hypervisor != nil {
		if err := m.Hypervisor.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("hypervisor")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("hypervisor")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateLabels(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Labels); i++ {

		if m.Labels[i] != nil {
			if err := m.Labels[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("labels" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("labels" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Cluster) contextValidateLicenseType(ctx context.Context, formats strfmt.Registry) error {

	if m.LicenseType != nil {
		if err := m.LicenseType.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("license_type")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("license_type")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateMetroAvailabilityChecklist(ctx context.Context, formats strfmt.Registry) error {

	if m.MetroAvailabilityChecklist != nil {
		if err := m.MetroAvailabilityChecklist.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metro_availability_checklist")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("metro_availability_checklist")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateNtpMode(ctx context.Context, formats strfmt.Registry) error {

	if m.NtpMode != nil {
		if err := m.NtpMode.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ntp_mode")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ntp_mode")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateSettings(ctx context.Context, formats strfmt.Registry) error {

	if m.Settings != nil {
		if err := m.Settings.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("settings")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("settings")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateSoftwareEdition(ctx context.Context, formats strfmt.Registry) error {

	if m.SoftwareEdition != nil {
		if err := m.SoftwareEdition.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("software_edition")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("software_edition")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if m.Type != nil {
		if err := m.Type.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("type")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("type")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateVcenterAccount(ctx context.Context, formats strfmt.Registry) error {

	if m.VcenterAccount != nil {
		if err := m.VcenterAccount.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vcenterAccount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("vcenterAccount")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateVdses(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Vdses); i++ {

		if m.Vdses[i] != nil {
			if err := m.Vdses[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("vdses" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("vdses" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Cluster) contextValidateVMFolders(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.VMFolders); i++ {

		if m.VMFolders[i] != nil {
			if err := m.VMFolders[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("vm_folders" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("vm_folders" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Cluster) contextValidateVMTemplates(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.VMTemplates); i++ {

		if m.VMTemplates[i] != nil {
			if err := m.VMTemplates[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("vm_templates" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("vm_templates" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Cluster) contextValidateVms(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Vms); i++ {

		if m.Vms[i] != nil {
			if err := m.Vms[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("vms" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("vms" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Cluster) contextValidateWitness(ctx context.Context, formats strfmt.Registry) error {

	if m.Witness != nil {
		if err := m.Witness.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("witness")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("witness")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateZones(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Zones); i++ {

		if m.Zones[i] != nil {
			if err := m.Zones[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("zones" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("zones" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *Cluster) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Cluster) UnmarshalBinary(b []byte) error {
	var res Cluster
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
