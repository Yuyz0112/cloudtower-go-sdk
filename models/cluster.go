// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Cluster cluster
//
// swagger:model Cluster
type Cluster struct {

	// applications
	Applications []*ClusterApplicationsItems0 `json:"applications,omitempty"`

	// architecture
	// Required: true
	Architecture *Architecture `json:"architecture"`

	// auto converge
	AutoConverge *bool `json:"auto_converge,omitempty"`

	// connect state
	// Required: true
	ConnectState *ConnectState `json:"connect_state"`

	// consistency groups
	ConsistencyGroups []*ClusterConsistencyGroupsItems0 `json:"consistency_groups,omitempty"`

	// current cpu model
	CurrentCPUModel *string `json:"current_cpu_model,omitempty"`

	// datacenters
	Datacenters []*ClusterDatacentersItems0 `json:"datacenters,omitempty"`

	// disconnected date
	DisconnectedDate *string `json:"disconnected_date,omitempty"`

	// disconnected reason
	DisconnectedReason interface{} `json:"disconnected_reason,omitempty"`

	// dns
	// Required: true
	DNS []string `json:"dns"`

	// entity async status
	EntityAsyncStatus interface{} `json:"entityAsyncStatus,omitempty"`

	// failure data space
	FailureDataSpace *float64 `json:"failure_data_space,omitempty"`

	// has metrox
	HasMetrox *bool `json:"has_metrox,omitempty"`

	// has remote backup
	HasRemoteBackup *bool `json:"has_remote_backup,omitempty"`

	// host num
	HostNum *float64 `json:"host_num,omitempty"`

	// hosts
	Hosts []*ClusterHostsItems0 `json:"hosts,omitempty"`

	// hypervisor
	Hypervisor interface{} `json:"hypervisor,omitempty"`

	// id
	// Required: true
	ID *string `json:"id"`

	// ip
	// Required: true
	IP *string `json:"ip"`

	// is all flash
	IsAllFlash *bool `json:"is_all_flash,omitempty"`

	// iscsi vip
	IscsiVip *string `json:"iscsi_vip,omitempty"`

	// labels
	Labels []*ClusterLabelsItems0 `json:"labels,omitempty"`

	// license expire date
	LicenseExpireDate *string `json:"license_expire_date,omitempty"`

	// license serial
	LicenseSerial *string `json:"license_serial,omitempty"`

	// license sign date
	LicenseSignDate *string `json:"license_sign_date,omitempty"`

	// license type
	LicenseType interface{} `json:"license_type,omitempty"`

	// local id
	LocalID *string `json:"local_id,omitempty"`

	// maintenance end date
	MaintenanceEndDate *string `json:"maintenance_end_date,omitempty"`

	// maintenance start date
	MaintenanceStartDate *string `json:"maintenance_start_date,omitempty"`

	// management vip
	ManagementVip *string `json:"management_vip,omitempty"`

	// max chunk num
	MaxChunkNum *float64 `json:"max_chunk_num,omitempty"`

	// max physical data capacity
	MaxPhysicalDataCapacity *float64 `json:"max_physical_data_capacity,omitempty"`

	// max physical data capacity per node
	MaxPhysicalDataCapacityPerNode *float64 `json:"max_physical_data_capacity_per_node,omitempty"`

	// metro availability checklist
	MetroAvailabilityChecklist *ClusterMetroAvailabilityChecklist `json:"metro_availability_checklist,omitempty"`

	// mgt gateway
	MgtGateway *string `json:"mgt_gateway,omitempty"`

	// mgt netmask
	MgtNetmask *string `json:"mgt_netmask,omitempty"`

	// migration data size
	MigrationDataSize *float64 `json:"migration_data_size,omitempty"`

	// migration speed
	MigrationSpeed *float64 `json:"migration_speed,omitempty"`

	// name
	// Required: true
	Name *string `json:"name"`

	// ntp mode
	NtpMode interface{} `json:"ntp_mode,omitempty"`

	// ntp servers
	// Required: true
	NtpServers []string `json:"ntp_servers"`

	// nvmf enabled
	NvmfEnabled *bool `json:"nvmf_enabled,omitempty"`

	// pmem enabled
	PmemEnabled *bool `json:"pmem_enabled,omitempty"`

	// provisioned cpu cores
	ProvisionedCPUCores *float64 `json:"provisioned_cpu_cores,omitempty"`

	// provisioned cpu cores for active vm
	ProvisionedCPUCoresForActiveVM *float64 `json:"provisioned_cpu_cores_for_active_vm,omitempty"`

	// provisioned for active vm ratio
	ProvisionedForActiveVMRatio *float64 `json:"provisioned_for_active_vm_ratio,omitempty"`

	// provisioned memory bytes
	ProvisionedMemoryBytes *float64 `json:"provisioned_memory_bytes,omitempty"`

	// provisioned ratio
	ProvisionedRatio *float64 `json:"provisioned_ratio,omitempty"`

	// rdma enabled
	RdmaEnabled *bool `json:"rdma_enabled,omitempty"`

	// recommended cpu models
	// Required: true
	RecommendedCPUModels []string `json:"recommended_cpu_models"`

	// recover data size
	RecoverDataSize *float64 `json:"recover_data_size,omitempty"`

	// recover speed
	RecoverSpeed *float64 `json:"recover_speed,omitempty"`

	// reserved cpu cores for system service
	ReservedCPUCoresForSystemService *float64 `json:"reserved_cpu_cores_for_system_service,omitempty"`

	// running vm num
	RunningVMNum *float64 `json:"running_vm_num,omitempty"`

	// settings
	Settings *ClusterSettings `json:"settings,omitempty"`

	// software edition
	SoftwareEdition interface{} `json:"software_edition,omitempty"`

	// stopped vm num
	StoppedVMNum *float64 `json:"stopped_vm_num,omitempty"`

	// stretch
	Stretch *bool `json:"stretch,omitempty"`

	// suspended vm num
	SuspendedVMNum *float64 `json:"suspended_vm_num,omitempty"`

	// total cache capacity
	TotalCacheCapacity *float64 `json:"total_cache_capacity,omitempty"`

	// total cpu cores
	TotalCPUCores *float64 `json:"total_cpu_cores,omitempty"`

	// total cpu hz
	TotalCPUHz *float64 `json:"total_cpu_hz,omitempty"`

	// total cpu models
	// Required: true
	TotalCPUModels []string `json:"total_cpu_models"`

	// total data capacity
	TotalDataCapacity *float64 `json:"total_data_capacity,omitempty"`

	// total memory bytes
	TotalMemoryBytes *float64 `json:"total_memory_bytes,omitempty"`

	// type
	// Required: true
	Type *ClusterType `json:"type"`

	// used cpu hz
	UsedCPUHz *float64 `json:"used_cpu_hz,omitempty"`

	// used data space
	UsedDataSpace *float64 `json:"used_data_space,omitempty"`

	// used memory bytes
	UsedMemoryBytes *float64 `json:"used_memory_bytes,omitempty"`

	// valid data space
	ValidDataSpace *float64 `json:"valid_data_space,omitempty"`

	// vcenter account
	VcenterAccount *ClusterVcenterAccount `json:"vcenterAccount,omitempty"`

	// vdses
	Vdses []*ClusterVdsesItems0 `json:"vdses,omitempty"`

	// version
	// Required: true
	Version *string `json:"version"`

	// vhost enabled
	VhostEnabled *bool `json:"vhost_enabled,omitempty"`

	// vm folders
	VMFolders []*ClusterVMFoldersItems0 `json:"vm_folders,omitempty"`

	// vm num
	VMNum *float64 `json:"vm_num,omitempty"`

	// vm templates
	VMTemplates []*ClusterVMTemplatesItems0 `json:"vm_templates,omitempty"`

	// vms
	Vms []*ClusterVmsItems0 `json:"vms,omitempty"`

	// witness
	Witness *ClusterWitness `json:"witness,omitempty"`

	// zones
	Zones []*ClusterZonesItems0 `json:"zones,omitempty"`
}

// Validate validates this cluster
func (m *Cluster) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateApplications(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateArchitecture(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConnectState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConsistencyGroups(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDatacenters(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDNS(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHosts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIP(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLabels(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMetroAvailabilityChecklist(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNtpServers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRecommendedCPUModels(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSettings(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTotalCPUModels(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVcenterAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVdses(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVMFolders(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVMTemplates(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVms(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWitness(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateZones(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Cluster) validateApplications(formats strfmt.Registry) error {
	if swag.IsZero(m.Applications) { // not required
		return nil
	}

	for i := 0; i < len(m.Applications); i++ {
		if swag.IsZero(m.Applications[i]) { // not required
			continue
		}

		if m.Applications[i] != nil {
			if err := m.Applications[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("applications" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Cluster) validateArchitecture(formats strfmt.Registry) error {

	if err := validate.Required("architecture", "body", m.Architecture); err != nil {
		return err
	}

	if err := validate.Required("architecture", "body", m.Architecture); err != nil {
		return err
	}

	if m.Architecture != nil {
		if err := m.Architecture.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("architecture")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateConnectState(formats strfmt.Registry) error {

	if err := validate.Required("connect_state", "body", m.ConnectState); err != nil {
		return err
	}

	if err := validate.Required("connect_state", "body", m.ConnectState); err != nil {
		return err
	}

	if m.ConnectState != nil {
		if err := m.ConnectState.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("connect_state")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateConsistencyGroups(formats strfmt.Registry) error {
	if swag.IsZero(m.ConsistencyGroups) { // not required
		return nil
	}

	for i := 0; i < len(m.ConsistencyGroups); i++ {
		if swag.IsZero(m.ConsistencyGroups[i]) { // not required
			continue
		}

		if m.ConsistencyGroups[i] != nil {
			if err := m.ConsistencyGroups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("consistency_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Cluster) validateDatacenters(formats strfmt.Registry) error {
	if swag.IsZero(m.Datacenters) { // not required
		return nil
	}

	for i := 0; i < len(m.Datacenters); i++ {
		if swag.IsZero(m.Datacenters[i]) { // not required
			continue
		}

		if m.Datacenters[i] != nil {
			if err := m.Datacenters[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("datacenters" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Cluster) validateDNS(formats strfmt.Registry) error {

	if err := validate.Required("dns", "body", m.DNS); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateHosts(formats strfmt.Registry) error {
	if swag.IsZero(m.Hosts) { // not required
		return nil
	}

	for i := 0; i < len(m.Hosts); i++ {
		if swag.IsZero(m.Hosts[i]) { // not required
			continue
		}

		if m.Hosts[i] != nil {
			if err := m.Hosts[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("hosts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Cluster) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateIP(formats strfmt.Registry) error {

	if err := validate.Required("ip", "body", m.IP); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateLabels(formats strfmt.Registry) error {
	if swag.IsZero(m.Labels) { // not required
		return nil
	}

	for i := 0; i < len(m.Labels); i++ {
		if swag.IsZero(m.Labels[i]) { // not required
			continue
		}

		if m.Labels[i] != nil {
			if err := m.Labels[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("labels" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Cluster) validateMetroAvailabilityChecklist(formats strfmt.Registry) error {
	if swag.IsZero(m.MetroAvailabilityChecklist) { // not required
		return nil
	}

	if m.MetroAvailabilityChecklist != nil {
		if err := m.MetroAvailabilityChecklist.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metro_availability_checklist")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateNtpServers(formats strfmt.Registry) error {

	if err := validate.Required("ntp_servers", "body", m.NtpServers); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateRecommendedCPUModels(formats strfmt.Registry) error {

	if err := validate.Required("recommended_cpu_models", "body", m.RecommendedCPUModels); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateSettings(formats strfmt.Registry) error {
	if swag.IsZero(m.Settings) { // not required
		return nil
	}

	if m.Settings != nil {
		if err := m.Settings.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("settings")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateTotalCPUModels(formats strfmt.Registry) error {

	if err := validate.Required("total_cpu_models", "body", m.TotalCPUModels); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateType(formats strfmt.Registry) error {

	if err := validate.Required("type", "body", m.Type); err != nil {
		return err
	}

	if err := validate.Required("type", "body", m.Type); err != nil {
		return err
	}

	if m.Type != nil {
		if err := m.Type.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("type")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateVcenterAccount(formats strfmt.Registry) error {
	if swag.IsZero(m.VcenterAccount) { // not required
		return nil
	}

	if m.VcenterAccount != nil {
		if err := m.VcenterAccount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vcenterAccount")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateVdses(formats strfmt.Registry) error {
	if swag.IsZero(m.Vdses) { // not required
		return nil
	}

	for i := 0; i < len(m.Vdses); i++ {
		if swag.IsZero(m.Vdses[i]) { // not required
			continue
		}

		if m.Vdses[i] != nil {
			if err := m.Vdses[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("vdses" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Cluster) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version", "body", m.Version); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateVMFolders(formats strfmt.Registry) error {
	if swag.IsZero(m.VMFolders) { // not required
		return nil
	}

	for i := 0; i < len(m.VMFolders); i++ {
		if swag.IsZero(m.VMFolders[i]) { // not required
			continue
		}

		if m.VMFolders[i] != nil {
			if err := m.VMFolders[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("vm_folders" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Cluster) validateVMTemplates(formats strfmt.Registry) error {
	if swag.IsZero(m.VMTemplates) { // not required
		return nil
	}

	for i := 0; i < len(m.VMTemplates); i++ {
		if swag.IsZero(m.VMTemplates[i]) { // not required
			continue
		}

		if m.VMTemplates[i] != nil {
			if err := m.VMTemplates[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("vm_templates" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Cluster) validateVms(formats strfmt.Registry) error {
	if swag.IsZero(m.Vms) { // not required
		return nil
	}

	for i := 0; i < len(m.Vms); i++ {
		if swag.IsZero(m.Vms[i]) { // not required
			continue
		}

		if m.Vms[i] != nil {
			if err := m.Vms[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("vms" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Cluster) validateWitness(formats strfmt.Registry) error {
	if swag.IsZero(m.Witness) { // not required
		return nil
	}

	if m.Witness != nil {
		if err := m.Witness.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("witness")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateZones(formats strfmt.Registry) error {
	if swag.IsZero(m.Zones) { // not required
		return nil
	}

	for i := 0; i < len(m.Zones); i++ {
		if swag.IsZero(m.Zones[i]) { // not required
			continue
		}

		if m.Zones[i] != nil {
			if err := m.Zones[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("zones" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this cluster based on the context it is used
func (m *Cluster) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateApplications(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateArchitecture(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateConnectState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateConsistencyGroups(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDatacenters(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHosts(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLabels(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMetroAvailabilityChecklist(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSettings(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVcenterAccount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVdses(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVMFolders(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVMTemplates(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVms(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateWitness(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateZones(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Cluster) contextValidateApplications(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Applications); i++ {

		if m.Applications[i] != nil {
			if err := m.Applications[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("applications" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Cluster) contextValidateArchitecture(ctx context.Context, formats strfmt.Registry) error {

	if m.Architecture != nil {
		if err := m.Architecture.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("architecture")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateConnectState(ctx context.Context, formats strfmt.Registry) error {

	if m.ConnectState != nil {
		if err := m.ConnectState.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("connect_state")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateConsistencyGroups(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ConsistencyGroups); i++ {

		if m.ConsistencyGroups[i] != nil {
			if err := m.ConsistencyGroups[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("consistency_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Cluster) contextValidateDatacenters(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Datacenters); i++ {

		if m.Datacenters[i] != nil {
			if err := m.Datacenters[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("datacenters" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Cluster) contextValidateHosts(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Hosts); i++ {

		if m.Hosts[i] != nil {
			if err := m.Hosts[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("hosts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Cluster) contextValidateLabels(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Labels); i++ {

		if m.Labels[i] != nil {
			if err := m.Labels[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("labels" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Cluster) contextValidateMetroAvailabilityChecklist(ctx context.Context, formats strfmt.Registry) error {

	if m.MetroAvailabilityChecklist != nil {
		if err := m.MetroAvailabilityChecklist.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metro_availability_checklist")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateSettings(ctx context.Context, formats strfmt.Registry) error {

	if m.Settings != nil {
		if err := m.Settings.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("settings")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if m.Type != nil {
		if err := m.Type.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("type")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateVcenterAccount(ctx context.Context, formats strfmt.Registry) error {

	if m.VcenterAccount != nil {
		if err := m.VcenterAccount.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vcenterAccount")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateVdses(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Vdses); i++ {

		if m.Vdses[i] != nil {
			if err := m.Vdses[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("vdses" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Cluster) contextValidateVMFolders(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.VMFolders); i++ {

		if m.VMFolders[i] != nil {
			if err := m.VMFolders[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("vm_folders" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Cluster) contextValidateVMTemplates(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.VMTemplates); i++ {

		if m.VMTemplates[i] != nil {
			if err := m.VMTemplates[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("vm_templates" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Cluster) contextValidateVms(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Vms); i++ {

		if m.Vms[i] != nil {
			if err := m.Vms[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("vms" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Cluster) contextValidateWitness(ctx context.Context, formats strfmt.Registry) error {

	if m.Witness != nil {
		if err := m.Witness.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("witness")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateZones(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Zones); i++ {

		if m.Zones[i] != nil {
			if err := m.Zones[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("zones" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *Cluster) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Cluster) UnmarshalBinary(b []byte) error {
	var res Cluster
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterApplicationsItems0 cluster applications items0
//
// swagger:model ClusterApplicationsItems0
type ClusterApplicationsItems0 struct {

	// id
	// Required: true
	ID *string `json:"id"`
}

// Validate validates this cluster applications items0
func (m *ClusterApplicationsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterApplicationsItems0) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this cluster applications items0 based on context it is used
func (m *ClusterApplicationsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ClusterApplicationsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterApplicationsItems0) UnmarshalBinary(b []byte) error {
	var res ClusterApplicationsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterConsistencyGroupsItems0 cluster consistency groups items0
//
// swagger:model ClusterConsistencyGroupsItems0
type ClusterConsistencyGroupsItems0 struct {

	// id
	// Required: true
	ID *string `json:"id"`

	// name
	// Required: true
	Name *string `json:"name"`
}

// Validate validates this cluster consistency groups items0
func (m *ClusterConsistencyGroupsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterConsistencyGroupsItems0) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

func (m *ClusterConsistencyGroupsItems0) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this cluster consistency groups items0 based on context it is used
func (m *ClusterConsistencyGroupsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ClusterConsistencyGroupsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterConsistencyGroupsItems0) UnmarshalBinary(b []byte) error {
	var res ClusterConsistencyGroupsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterDatacentersItems0 cluster datacenters items0
//
// swagger:model ClusterDatacentersItems0
type ClusterDatacentersItems0 struct {

	// id
	// Required: true
	ID *string `json:"id"`

	// name
	// Required: true
	Name *string `json:"name"`
}

// Validate validates this cluster datacenters items0
func (m *ClusterDatacentersItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterDatacentersItems0) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

func (m *ClusterDatacentersItems0) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this cluster datacenters items0 based on context it is used
func (m *ClusterDatacentersItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ClusterDatacentersItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterDatacentersItems0) UnmarshalBinary(b []byte) error {
	var res ClusterDatacentersItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterHostsItems0 cluster hosts items0
//
// swagger:model ClusterHostsItems0
type ClusterHostsItems0 struct {

	// id
	// Required: true
	ID *string `json:"id"`

	// name
	// Required: true
	Name *string `json:"name"`
}

// Validate validates this cluster hosts items0
func (m *ClusterHostsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterHostsItems0) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

func (m *ClusterHostsItems0) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this cluster hosts items0 based on context it is used
func (m *ClusterHostsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ClusterHostsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterHostsItems0) UnmarshalBinary(b []byte) error {
	var res ClusterHostsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterLabelsItems0 cluster labels items0
//
// swagger:model ClusterLabelsItems0
type ClusterLabelsItems0 struct {

	// id
	// Required: true
	ID *string `json:"id"`
}

// Validate validates this cluster labels items0
func (m *ClusterLabelsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterLabelsItems0) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this cluster labels items0 based on context it is used
func (m *ClusterLabelsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ClusterLabelsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterLabelsItems0) UnmarshalBinary(b []byte) error {
	var res ClusterLabelsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterMetroAvailabilityChecklist cluster metro availability checklist
//
// swagger:model ClusterMetroAvailabilityChecklist
type ClusterMetroAvailabilityChecklist struct {

	// primary zone
	// Required: true
	PrimaryZone *ClusterMetroAvailabilityChecklistPrimaryZone `json:"primaryZone"`

	// primary zone and witness
	// Required: true
	PrimaryZoneAndWitness *ClusterMetroAvailabilityChecklistPrimaryZoneAndWitness `json:"primaryZoneAndWitness"`

	// secondary zone
	// Required: true
	SecondaryZone *ClusterMetroAvailabilityChecklistSecondaryZone `json:"secondaryZone"`

	// secondary zone and witness
	// Required: true
	SecondaryZoneAndWitness *ClusterMetroAvailabilityChecklistSecondaryZoneAndWitness `json:"secondaryZoneAndWitness"`

	// witness
	// Required: true
	Witness *ClusterMetroAvailabilityChecklistWitness `json:"witness"`

	// zone and zone
	// Required: true
	ZoneAndZone *ClusterMetroAvailabilityChecklistZoneAndZone `json:"zoneAndZone"`
}

// Validate validates this cluster metro availability checklist
func (m *ClusterMetroAvailabilityChecklist) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePrimaryZone(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrimaryZoneAndWitness(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSecondaryZone(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSecondaryZoneAndWitness(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWitness(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateZoneAndZone(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterMetroAvailabilityChecklist) validatePrimaryZone(formats strfmt.Registry) error {

	if err := validate.Required("metro_availability_checklist"+"."+"primaryZone", "body", m.PrimaryZone); err != nil {
		return err
	}

	if m.PrimaryZone != nil {
		if err := m.PrimaryZone.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metro_availability_checklist" + "." + "primaryZone")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklist) validatePrimaryZoneAndWitness(formats strfmt.Registry) error {

	if err := validate.Required("metro_availability_checklist"+"."+"primaryZoneAndWitness", "body", m.PrimaryZoneAndWitness); err != nil {
		return err
	}

	if m.PrimaryZoneAndWitness != nil {
		if err := m.PrimaryZoneAndWitness.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metro_availability_checklist" + "." + "primaryZoneAndWitness")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklist) validateSecondaryZone(formats strfmt.Registry) error {

	if err := validate.Required("metro_availability_checklist"+"."+"secondaryZone", "body", m.SecondaryZone); err != nil {
		return err
	}

	if m.SecondaryZone != nil {
		if err := m.SecondaryZone.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metro_availability_checklist" + "." + "secondaryZone")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklist) validateSecondaryZoneAndWitness(formats strfmt.Registry) error {

	if err := validate.Required("metro_availability_checklist"+"."+"secondaryZoneAndWitness", "body", m.SecondaryZoneAndWitness); err != nil {
		return err
	}

	if m.SecondaryZoneAndWitness != nil {
		if err := m.SecondaryZoneAndWitness.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metro_availability_checklist" + "." + "secondaryZoneAndWitness")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklist) validateWitness(formats strfmt.Registry) error {

	if err := validate.Required("metro_availability_checklist"+"."+"witness", "body", m.Witness); err != nil {
		return err
	}

	if m.Witness != nil {
		if err := m.Witness.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metro_availability_checklist" + "." + "witness")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklist) validateZoneAndZone(formats strfmt.Registry) error {

	if err := validate.Required("metro_availability_checklist"+"."+"zoneAndZone", "body", m.ZoneAndZone); err != nil {
		return err
	}

	if m.ZoneAndZone != nil {
		if err := m.ZoneAndZone.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metro_availability_checklist" + "." + "zoneAndZone")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster metro availability checklist based on the context it is used
func (m *ClusterMetroAvailabilityChecklist) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePrimaryZone(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePrimaryZoneAndWitness(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSecondaryZone(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSecondaryZoneAndWitness(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateWitness(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateZoneAndZone(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterMetroAvailabilityChecklist) contextValidatePrimaryZone(ctx context.Context, formats strfmt.Registry) error {

	if m.PrimaryZone != nil {
		if err := m.PrimaryZone.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metro_availability_checklist" + "." + "primaryZone")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklist) contextValidatePrimaryZoneAndWitness(ctx context.Context, formats strfmt.Registry) error {

	if m.PrimaryZoneAndWitness != nil {
		if err := m.PrimaryZoneAndWitness.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metro_availability_checklist" + "." + "primaryZoneAndWitness")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklist) contextValidateSecondaryZone(ctx context.Context, formats strfmt.Registry) error {

	if m.SecondaryZone != nil {
		if err := m.SecondaryZone.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metro_availability_checklist" + "." + "secondaryZone")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklist) contextValidateSecondaryZoneAndWitness(ctx context.Context, formats strfmt.Registry) error {

	if m.SecondaryZoneAndWitness != nil {
		if err := m.SecondaryZoneAndWitness.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metro_availability_checklist" + "." + "secondaryZoneAndWitness")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklist) contextValidateWitness(ctx context.Context, formats strfmt.Registry) error {

	if m.Witness != nil {
		if err := m.Witness.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metro_availability_checklist" + "." + "witness")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklist) contextValidateZoneAndZone(ctx context.Context, formats strfmt.Registry) error {

	if m.ZoneAndZone != nil {
		if err := m.ZoneAndZone.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metro_availability_checklist" + "." + "zoneAndZone")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterMetroAvailabilityChecklist) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterMetroAvailabilityChecklist) UnmarshalBinary(b []byte) error {
	var res ClusterMetroAvailabilityChecklist
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterMetroAvailabilityChecklistPrimaryZone cluster metro availability checklist primary zone
//
// swagger:model ClusterMetroAvailabilityChecklistPrimaryZone
type ClusterMetroAvailabilityChecklistPrimaryZone struct {

	// critical
	// Required: true
	Critical *float64 `json:"critical"`

	// info
	// Required: true
	Info *float64 `json:"info"`

	// items
	// Required: true
	Items []*ClusterMetroAvailabilityChecklistPrimaryZoneItemsItems0 `json:"items"`

	// notice
	// Required: true
	Notice *float64 `json:"notice"`

	// status
	// Required: true
	Status *MetroCheckStatusEnum `json:"status"`
}

// Validate validates this cluster metro availability checklist primary zone
func (m *ClusterMetroAvailabilityChecklistPrimaryZone) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCritical(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateItems(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNotice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterMetroAvailabilityChecklistPrimaryZone) validateCritical(formats strfmt.Registry) error {

	if err := validate.Required("metro_availability_checklist"+"."+"primaryZone"+"."+"critical", "body", m.Critical); err != nil {
		return err
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistPrimaryZone) validateInfo(formats strfmt.Registry) error {

	if err := validate.Required("metro_availability_checklist"+"."+"primaryZone"+"."+"info", "body", m.Info); err != nil {
		return err
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistPrimaryZone) validateItems(formats strfmt.Registry) error {

	if err := validate.Required("metro_availability_checklist"+"."+"primaryZone"+"."+"items", "body", m.Items); err != nil {
		return err
	}

	for i := 0; i < len(m.Items); i++ {
		if swag.IsZero(m.Items[i]) { // not required
			continue
		}

		if m.Items[i] != nil {
			if err := m.Items[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("metro_availability_checklist" + "." + "primaryZone" + "." + "items" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistPrimaryZone) validateNotice(formats strfmt.Registry) error {

	if err := validate.Required("metro_availability_checklist"+"."+"primaryZone"+"."+"notice", "body", m.Notice); err != nil {
		return err
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistPrimaryZone) validateStatus(formats strfmt.Registry) error {

	if err := validate.Required("metro_availability_checklist"+"."+"primaryZone"+"."+"status", "body", m.Status); err != nil {
		return err
	}

	if err := validate.Required("metro_availability_checklist"+"."+"primaryZone"+"."+"status", "body", m.Status); err != nil {
		return err
	}

	if m.Status != nil {
		if err := m.Status.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metro_availability_checklist" + "." + "primaryZone" + "." + "status")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster metro availability checklist primary zone based on the context it is used
func (m *ClusterMetroAvailabilityChecklistPrimaryZone) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateItems(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterMetroAvailabilityChecklistPrimaryZone) contextValidateItems(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Items); i++ {

		if m.Items[i] != nil {
			if err := m.Items[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("metro_availability_checklist" + "." + "primaryZone" + "." + "items" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistPrimaryZone) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if m.Status != nil {
		if err := m.Status.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metro_availability_checklist" + "." + "primaryZone" + "." + "status")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterMetroAvailabilityChecklistPrimaryZone) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterMetroAvailabilityChecklistPrimaryZone) UnmarshalBinary(b []byte) error {
	var res ClusterMetroAvailabilityChecklistPrimaryZone
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterMetroAvailabilityChecklistPrimaryZoneAndWitness cluster metro availability checklist primary zone and witness
//
// swagger:model ClusterMetroAvailabilityChecklistPrimaryZoneAndWitness
type ClusterMetroAvailabilityChecklistPrimaryZoneAndWitness struct {

	// critical
	// Required: true
	Critical *float64 `json:"critical"`

	// info
	// Required: true
	Info *float64 `json:"info"`

	// items
	// Required: true
	Items []*ClusterMetroAvailabilityChecklistPrimaryZoneAndWitnessItemsItems0 `json:"items"`

	// notice
	// Required: true
	Notice *float64 `json:"notice"`

	// status
	// Required: true
	Status *MetroCheckStatusEnum `json:"status"`
}

// Validate validates this cluster metro availability checklist primary zone and witness
func (m *ClusterMetroAvailabilityChecklistPrimaryZoneAndWitness) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCritical(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateItems(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNotice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterMetroAvailabilityChecklistPrimaryZoneAndWitness) validateCritical(formats strfmt.Registry) error {

	if err := validate.Required("metro_availability_checklist"+"."+"primaryZoneAndWitness"+"."+"critical", "body", m.Critical); err != nil {
		return err
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistPrimaryZoneAndWitness) validateInfo(formats strfmt.Registry) error {

	if err := validate.Required("metro_availability_checklist"+"."+"primaryZoneAndWitness"+"."+"info", "body", m.Info); err != nil {
		return err
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistPrimaryZoneAndWitness) validateItems(formats strfmt.Registry) error {

	if err := validate.Required("metro_availability_checklist"+"."+"primaryZoneAndWitness"+"."+"items", "body", m.Items); err != nil {
		return err
	}

	for i := 0; i < len(m.Items); i++ {
		if swag.IsZero(m.Items[i]) { // not required
			continue
		}

		if m.Items[i] != nil {
			if err := m.Items[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("metro_availability_checklist" + "." + "primaryZoneAndWitness" + "." + "items" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistPrimaryZoneAndWitness) validateNotice(formats strfmt.Registry) error {

	if err := validate.Required("metro_availability_checklist"+"."+"primaryZoneAndWitness"+"."+"notice", "body", m.Notice); err != nil {
		return err
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistPrimaryZoneAndWitness) validateStatus(formats strfmt.Registry) error {

	if err := validate.Required("metro_availability_checklist"+"."+"primaryZoneAndWitness"+"."+"status", "body", m.Status); err != nil {
		return err
	}

	if err := validate.Required("metro_availability_checklist"+"."+"primaryZoneAndWitness"+"."+"status", "body", m.Status); err != nil {
		return err
	}

	if m.Status != nil {
		if err := m.Status.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metro_availability_checklist" + "." + "primaryZoneAndWitness" + "." + "status")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster metro availability checklist primary zone and witness based on the context it is used
func (m *ClusterMetroAvailabilityChecklistPrimaryZoneAndWitness) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateItems(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterMetroAvailabilityChecklistPrimaryZoneAndWitness) contextValidateItems(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Items); i++ {

		if m.Items[i] != nil {
			if err := m.Items[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("metro_availability_checklist" + "." + "primaryZoneAndWitness" + "." + "items" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistPrimaryZoneAndWitness) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if m.Status != nil {
		if err := m.Status.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metro_availability_checklist" + "." + "primaryZoneAndWitness" + "." + "status")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterMetroAvailabilityChecklistPrimaryZoneAndWitness) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterMetroAvailabilityChecklistPrimaryZoneAndWitness) UnmarshalBinary(b []byte) error {
	var res ClusterMetroAvailabilityChecklistPrimaryZoneAndWitness
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterMetroAvailabilityChecklistPrimaryZoneAndWitnessItemsItems0 cluster metro availability checklist primary zone and witness items items0
//
// swagger:model ClusterMetroAvailabilityChecklistPrimaryZoneAndWitnessItemsItems0
type ClusterMetroAvailabilityChecklistPrimaryZoneAndWitnessItemsItems0 struct {

	// critical
	// Required: true
	Critical []string `json:"critical"`

	// info
	// Required: true
	Info []string `json:"info"`

	// key
	// Required: true
	Key *string `json:"key"`

	// labels
	// Required: true
	Labels interface{} `json:"labels"`

	// notice
	// Required: true
	Notice []string `json:"notice"`

	// status
	// Required: true
	Status *MetroCheckStatusEnum `json:"status"`
}

// Validate validates this cluster metro availability checklist primary zone and witness items items0
func (m *ClusterMetroAvailabilityChecklistPrimaryZoneAndWitnessItemsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCritical(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateKey(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLabels(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNotice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterMetroAvailabilityChecklistPrimaryZoneAndWitnessItemsItems0) validateCritical(formats strfmt.Registry) error {

	if err := validate.Required("critical", "body", m.Critical); err != nil {
		return err
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistPrimaryZoneAndWitnessItemsItems0) validateInfo(formats strfmt.Registry) error {

	if err := validate.Required("info", "body", m.Info); err != nil {
		return err
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistPrimaryZoneAndWitnessItemsItems0) validateKey(formats strfmt.Registry) error {

	if err := validate.Required("key", "body", m.Key); err != nil {
		return err
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistPrimaryZoneAndWitnessItemsItems0) validateLabels(formats strfmt.Registry) error {

	if m.Labels == nil {
		return errors.Required("labels", "body", nil)
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistPrimaryZoneAndWitnessItemsItems0) validateNotice(formats strfmt.Registry) error {

	if err := validate.Required("notice", "body", m.Notice); err != nil {
		return err
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistPrimaryZoneAndWitnessItemsItems0) validateStatus(formats strfmt.Registry) error {

	if err := validate.Required("status", "body", m.Status); err != nil {
		return err
	}

	if err := validate.Required("status", "body", m.Status); err != nil {
		return err
	}

	if m.Status != nil {
		if err := m.Status.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("status")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster metro availability checklist primary zone and witness items items0 based on the context it is used
func (m *ClusterMetroAvailabilityChecklistPrimaryZoneAndWitnessItemsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterMetroAvailabilityChecklistPrimaryZoneAndWitnessItemsItems0) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if m.Status != nil {
		if err := m.Status.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("status")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterMetroAvailabilityChecklistPrimaryZoneAndWitnessItemsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterMetroAvailabilityChecklistPrimaryZoneAndWitnessItemsItems0) UnmarshalBinary(b []byte) error {
	var res ClusterMetroAvailabilityChecklistPrimaryZoneAndWitnessItemsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterMetroAvailabilityChecklistPrimaryZoneItemsItems0 cluster metro availability checklist primary zone items items0
//
// swagger:model ClusterMetroAvailabilityChecklistPrimaryZoneItemsItems0
type ClusterMetroAvailabilityChecklistPrimaryZoneItemsItems0 struct {

	// critical
	// Required: true
	Critical []string `json:"critical"`

	// info
	// Required: true
	Info []string `json:"info"`

	// key
	// Required: true
	Key *string `json:"key"`

	// labels
	// Required: true
	Labels interface{} `json:"labels"`

	// notice
	// Required: true
	Notice []string `json:"notice"`

	// status
	// Required: true
	Status *MetroCheckStatusEnum `json:"status"`
}

// Validate validates this cluster metro availability checklist primary zone items items0
func (m *ClusterMetroAvailabilityChecklistPrimaryZoneItemsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCritical(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateKey(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLabels(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNotice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterMetroAvailabilityChecklistPrimaryZoneItemsItems0) validateCritical(formats strfmt.Registry) error {

	if err := validate.Required("critical", "body", m.Critical); err != nil {
		return err
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistPrimaryZoneItemsItems0) validateInfo(formats strfmt.Registry) error {

	if err := validate.Required("info", "body", m.Info); err != nil {
		return err
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistPrimaryZoneItemsItems0) validateKey(formats strfmt.Registry) error {

	if err := validate.Required("key", "body", m.Key); err != nil {
		return err
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistPrimaryZoneItemsItems0) validateLabels(formats strfmt.Registry) error {

	if m.Labels == nil {
		return errors.Required("labels", "body", nil)
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistPrimaryZoneItemsItems0) validateNotice(formats strfmt.Registry) error {

	if err := validate.Required("notice", "body", m.Notice); err != nil {
		return err
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistPrimaryZoneItemsItems0) validateStatus(formats strfmt.Registry) error {

	if err := validate.Required("status", "body", m.Status); err != nil {
		return err
	}

	if err := validate.Required("status", "body", m.Status); err != nil {
		return err
	}

	if m.Status != nil {
		if err := m.Status.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("status")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster metro availability checklist primary zone items items0 based on the context it is used
func (m *ClusterMetroAvailabilityChecklistPrimaryZoneItemsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterMetroAvailabilityChecklistPrimaryZoneItemsItems0) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if m.Status != nil {
		if err := m.Status.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("status")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterMetroAvailabilityChecklistPrimaryZoneItemsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterMetroAvailabilityChecklistPrimaryZoneItemsItems0) UnmarshalBinary(b []byte) error {
	var res ClusterMetroAvailabilityChecklistPrimaryZoneItemsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterMetroAvailabilityChecklistSecondaryZone cluster metro availability checklist secondary zone
//
// swagger:model ClusterMetroAvailabilityChecklistSecondaryZone
type ClusterMetroAvailabilityChecklistSecondaryZone struct {

	// critical
	// Required: true
	Critical *float64 `json:"critical"`

	// info
	// Required: true
	Info *float64 `json:"info"`

	// items
	// Required: true
	Items []*ClusterMetroAvailabilityChecklistSecondaryZoneItemsItems0 `json:"items"`

	// notice
	// Required: true
	Notice *float64 `json:"notice"`

	// status
	// Required: true
	Status *MetroCheckStatusEnum `json:"status"`
}

// Validate validates this cluster metro availability checklist secondary zone
func (m *ClusterMetroAvailabilityChecklistSecondaryZone) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCritical(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateItems(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNotice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterMetroAvailabilityChecklistSecondaryZone) validateCritical(formats strfmt.Registry) error {

	if err := validate.Required("metro_availability_checklist"+"."+"secondaryZone"+"."+"critical", "body", m.Critical); err != nil {
		return err
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistSecondaryZone) validateInfo(formats strfmt.Registry) error {

	if err := validate.Required("metro_availability_checklist"+"."+"secondaryZone"+"."+"info", "body", m.Info); err != nil {
		return err
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistSecondaryZone) validateItems(formats strfmt.Registry) error {

	if err := validate.Required("metro_availability_checklist"+"."+"secondaryZone"+"."+"items", "body", m.Items); err != nil {
		return err
	}

	for i := 0; i < len(m.Items); i++ {
		if swag.IsZero(m.Items[i]) { // not required
			continue
		}

		if m.Items[i] != nil {
			if err := m.Items[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("metro_availability_checklist" + "." + "secondaryZone" + "." + "items" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistSecondaryZone) validateNotice(formats strfmt.Registry) error {

	if err := validate.Required("metro_availability_checklist"+"."+"secondaryZone"+"."+"notice", "body", m.Notice); err != nil {
		return err
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistSecondaryZone) validateStatus(formats strfmt.Registry) error {

	if err := validate.Required("metro_availability_checklist"+"."+"secondaryZone"+"."+"status", "body", m.Status); err != nil {
		return err
	}

	if err := validate.Required("metro_availability_checklist"+"."+"secondaryZone"+"."+"status", "body", m.Status); err != nil {
		return err
	}

	if m.Status != nil {
		if err := m.Status.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metro_availability_checklist" + "." + "secondaryZone" + "." + "status")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster metro availability checklist secondary zone based on the context it is used
func (m *ClusterMetroAvailabilityChecklistSecondaryZone) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateItems(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterMetroAvailabilityChecklistSecondaryZone) contextValidateItems(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Items); i++ {

		if m.Items[i] != nil {
			if err := m.Items[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("metro_availability_checklist" + "." + "secondaryZone" + "." + "items" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistSecondaryZone) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if m.Status != nil {
		if err := m.Status.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metro_availability_checklist" + "." + "secondaryZone" + "." + "status")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterMetroAvailabilityChecklistSecondaryZone) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterMetroAvailabilityChecklistSecondaryZone) UnmarshalBinary(b []byte) error {
	var res ClusterMetroAvailabilityChecklistSecondaryZone
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterMetroAvailabilityChecklistSecondaryZoneAndWitness cluster metro availability checklist secondary zone and witness
//
// swagger:model ClusterMetroAvailabilityChecklistSecondaryZoneAndWitness
type ClusterMetroAvailabilityChecklistSecondaryZoneAndWitness struct {

	// critical
	// Required: true
	Critical *float64 `json:"critical"`

	// info
	// Required: true
	Info *float64 `json:"info"`

	// items
	// Required: true
	Items []*ClusterMetroAvailabilityChecklistSecondaryZoneAndWitnessItemsItems0 `json:"items"`

	// notice
	// Required: true
	Notice *float64 `json:"notice"`

	// status
	// Required: true
	Status *MetroCheckStatusEnum `json:"status"`
}

// Validate validates this cluster metro availability checklist secondary zone and witness
func (m *ClusterMetroAvailabilityChecklistSecondaryZoneAndWitness) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCritical(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateItems(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNotice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterMetroAvailabilityChecklistSecondaryZoneAndWitness) validateCritical(formats strfmt.Registry) error {

	if err := validate.Required("metro_availability_checklist"+"."+"secondaryZoneAndWitness"+"."+"critical", "body", m.Critical); err != nil {
		return err
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistSecondaryZoneAndWitness) validateInfo(formats strfmt.Registry) error {

	if err := validate.Required("metro_availability_checklist"+"."+"secondaryZoneAndWitness"+"."+"info", "body", m.Info); err != nil {
		return err
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistSecondaryZoneAndWitness) validateItems(formats strfmt.Registry) error {

	if err := validate.Required("metro_availability_checklist"+"."+"secondaryZoneAndWitness"+"."+"items", "body", m.Items); err != nil {
		return err
	}

	for i := 0; i < len(m.Items); i++ {
		if swag.IsZero(m.Items[i]) { // not required
			continue
		}

		if m.Items[i] != nil {
			if err := m.Items[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("metro_availability_checklist" + "." + "secondaryZoneAndWitness" + "." + "items" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistSecondaryZoneAndWitness) validateNotice(formats strfmt.Registry) error {

	if err := validate.Required("metro_availability_checklist"+"."+"secondaryZoneAndWitness"+"."+"notice", "body", m.Notice); err != nil {
		return err
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistSecondaryZoneAndWitness) validateStatus(formats strfmt.Registry) error {

	if err := validate.Required("metro_availability_checklist"+"."+"secondaryZoneAndWitness"+"."+"status", "body", m.Status); err != nil {
		return err
	}

	if err := validate.Required("metro_availability_checklist"+"."+"secondaryZoneAndWitness"+"."+"status", "body", m.Status); err != nil {
		return err
	}

	if m.Status != nil {
		if err := m.Status.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metro_availability_checklist" + "." + "secondaryZoneAndWitness" + "." + "status")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster metro availability checklist secondary zone and witness based on the context it is used
func (m *ClusterMetroAvailabilityChecklistSecondaryZoneAndWitness) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateItems(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterMetroAvailabilityChecklistSecondaryZoneAndWitness) contextValidateItems(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Items); i++ {

		if m.Items[i] != nil {
			if err := m.Items[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("metro_availability_checklist" + "." + "secondaryZoneAndWitness" + "." + "items" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistSecondaryZoneAndWitness) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if m.Status != nil {
		if err := m.Status.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metro_availability_checklist" + "." + "secondaryZoneAndWitness" + "." + "status")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterMetroAvailabilityChecklistSecondaryZoneAndWitness) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterMetroAvailabilityChecklistSecondaryZoneAndWitness) UnmarshalBinary(b []byte) error {
	var res ClusterMetroAvailabilityChecklistSecondaryZoneAndWitness
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterMetroAvailabilityChecklistSecondaryZoneAndWitnessItemsItems0 cluster metro availability checklist secondary zone and witness items items0
//
// swagger:model ClusterMetroAvailabilityChecklistSecondaryZoneAndWitnessItemsItems0
type ClusterMetroAvailabilityChecklistSecondaryZoneAndWitnessItemsItems0 struct {

	// critical
	// Required: true
	Critical []string `json:"critical"`

	// info
	// Required: true
	Info []string `json:"info"`

	// key
	// Required: true
	Key *string `json:"key"`

	// labels
	// Required: true
	Labels interface{} `json:"labels"`

	// notice
	// Required: true
	Notice []string `json:"notice"`

	// status
	// Required: true
	Status *MetroCheckStatusEnum `json:"status"`
}

// Validate validates this cluster metro availability checklist secondary zone and witness items items0
func (m *ClusterMetroAvailabilityChecklistSecondaryZoneAndWitnessItemsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCritical(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateKey(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLabels(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNotice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterMetroAvailabilityChecklistSecondaryZoneAndWitnessItemsItems0) validateCritical(formats strfmt.Registry) error {

	if err := validate.Required("critical", "body", m.Critical); err != nil {
		return err
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistSecondaryZoneAndWitnessItemsItems0) validateInfo(formats strfmt.Registry) error {

	if err := validate.Required("info", "body", m.Info); err != nil {
		return err
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistSecondaryZoneAndWitnessItemsItems0) validateKey(formats strfmt.Registry) error {

	if err := validate.Required("key", "body", m.Key); err != nil {
		return err
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistSecondaryZoneAndWitnessItemsItems0) validateLabels(formats strfmt.Registry) error {

	if m.Labels == nil {
		return errors.Required("labels", "body", nil)
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistSecondaryZoneAndWitnessItemsItems0) validateNotice(formats strfmt.Registry) error {

	if err := validate.Required("notice", "body", m.Notice); err != nil {
		return err
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistSecondaryZoneAndWitnessItemsItems0) validateStatus(formats strfmt.Registry) error {

	if err := validate.Required("status", "body", m.Status); err != nil {
		return err
	}

	if err := validate.Required("status", "body", m.Status); err != nil {
		return err
	}

	if m.Status != nil {
		if err := m.Status.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("status")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster metro availability checklist secondary zone and witness items items0 based on the context it is used
func (m *ClusterMetroAvailabilityChecklistSecondaryZoneAndWitnessItemsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterMetroAvailabilityChecklistSecondaryZoneAndWitnessItemsItems0) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if m.Status != nil {
		if err := m.Status.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("status")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterMetroAvailabilityChecklistSecondaryZoneAndWitnessItemsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterMetroAvailabilityChecklistSecondaryZoneAndWitnessItemsItems0) UnmarshalBinary(b []byte) error {
	var res ClusterMetroAvailabilityChecklistSecondaryZoneAndWitnessItemsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterMetroAvailabilityChecklistSecondaryZoneItemsItems0 cluster metro availability checklist secondary zone items items0
//
// swagger:model ClusterMetroAvailabilityChecklistSecondaryZoneItemsItems0
type ClusterMetroAvailabilityChecklistSecondaryZoneItemsItems0 struct {

	// critical
	// Required: true
	Critical []string `json:"critical"`

	// info
	// Required: true
	Info []string `json:"info"`

	// key
	// Required: true
	Key *string `json:"key"`

	// labels
	// Required: true
	Labels interface{} `json:"labels"`

	// notice
	// Required: true
	Notice []string `json:"notice"`

	// status
	// Required: true
	Status *MetroCheckStatusEnum `json:"status"`
}

// Validate validates this cluster metro availability checklist secondary zone items items0
func (m *ClusterMetroAvailabilityChecklistSecondaryZoneItemsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCritical(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateKey(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLabels(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNotice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterMetroAvailabilityChecklistSecondaryZoneItemsItems0) validateCritical(formats strfmt.Registry) error {

	if err := validate.Required("critical", "body", m.Critical); err != nil {
		return err
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistSecondaryZoneItemsItems0) validateInfo(formats strfmt.Registry) error {

	if err := validate.Required("info", "body", m.Info); err != nil {
		return err
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistSecondaryZoneItemsItems0) validateKey(formats strfmt.Registry) error {

	if err := validate.Required("key", "body", m.Key); err != nil {
		return err
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistSecondaryZoneItemsItems0) validateLabels(formats strfmt.Registry) error {

	if m.Labels == nil {
		return errors.Required("labels", "body", nil)
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistSecondaryZoneItemsItems0) validateNotice(formats strfmt.Registry) error {

	if err := validate.Required("notice", "body", m.Notice); err != nil {
		return err
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistSecondaryZoneItemsItems0) validateStatus(formats strfmt.Registry) error {

	if err := validate.Required("status", "body", m.Status); err != nil {
		return err
	}

	if err := validate.Required("status", "body", m.Status); err != nil {
		return err
	}

	if m.Status != nil {
		if err := m.Status.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("status")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster metro availability checklist secondary zone items items0 based on the context it is used
func (m *ClusterMetroAvailabilityChecklistSecondaryZoneItemsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterMetroAvailabilityChecklistSecondaryZoneItemsItems0) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if m.Status != nil {
		if err := m.Status.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("status")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterMetroAvailabilityChecklistSecondaryZoneItemsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterMetroAvailabilityChecklistSecondaryZoneItemsItems0) UnmarshalBinary(b []byte) error {
	var res ClusterMetroAvailabilityChecklistSecondaryZoneItemsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterMetroAvailabilityChecklistWitness cluster metro availability checklist witness
//
// swagger:model ClusterMetroAvailabilityChecklistWitness
type ClusterMetroAvailabilityChecklistWitness struct {

	// critical
	// Required: true
	Critical *float64 `json:"critical"`

	// info
	// Required: true
	Info *float64 `json:"info"`

	// items
	// Required: true
	Items []*ClusterMetroAvailabilityChecklistWitnessItemsItems0 `json:"items"`

	// notice
	// Required: true
	Notice *float64 `json:"notice"`

	// status
	// Required: true
	Status *MetroCheckStatusEnum `json:"status"`
}

// Validate validates this cluster metro availability checklist witness
func (m *ClusterMetroAvailabilityChecklistWitness) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCritical(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateItems(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNotice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterMetroAvailabilityChecklistWitness) validateCritical(formats strfmt.Registry) error {

	if err := validate.Required("metro_availability_checklist"+"."+"witness"+"."+"critical", "body", m.Critical); err != nil {
		return err
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistWitness) validateInfo(formats strfmt.Registry) error {

	if err := validate.Required("metro_availability_checklist"+"."+"witness"+"."+"info", "body", m.Info); err != nil {
		return err
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistWitness) validateItems(formats strfmt.Registry) error {

	if err := validate.Required("metro_availability_checklist"+"."+"witness"+"."+"items", "body", m.Items); err != nil {
		return err
	}

	for i := 0; i < len(m.Items); i++ {
		if swag.IsZero(m.Items[i]) { // not required
			continue
		}

		if m.Items[i] != nil {
			if err := m.Items[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("metro_availability_checklist" + "." + "witness" + "." + "items" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistWitness) validateNotice(formats strfmt.Registry) error {

	if err := validate.Required("metro_availability_checklist"+"."+"witness"+"."+"notice", "body", m.Notice); err != nil {
		return err
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistWitness) validateStatus(formats strfmt.Registry) error {

	if err := validate.Required("metro_availability_checklist"+"."+"witness"+"."+"status", "body", m.Status); err != nil {
		return err
	}

	if err := validate.Required("metro_availability_checklist"+"."+"witness"+"."+"status", "body", m.Status); err != nil {
		return err
	}

	if m.Status != nil {
		if err := m.Status.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metro_availability_checklist" + "." + "witness" + "." + "status")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster metro availability checklist witness based on the context it is used
func (m *ClusterMetroAvailabilityChecklistWitness) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateItems(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterMetroAvailabilityChecklistWitness) contextValidateItems(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Items); i++ {

		if m.Items[i] != nil {
			if err := m.Items[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("metro_availability_checklist" + "." + "witness" + "." + "items" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistWitness) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if m.Status != nil {
		if err := m.Status.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metro_availability_checklist" + "." + "witness" + "." + "status")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterMetroAvailabilityChecklistWitness) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterMetroAvailabilityChecklistWitness) UnmarshalBinary(b []byte) error {
	var res ClusterMetroAvailabilityChecklistWitness
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterMetroAvailabilityChecklistWitnessItemsItems0 cluster metro availability checklist witness items items0
//
// swagger:model ClusterMetroAvailabilityChecklistWitnessItemsItems0
type ClusterMetroAvailabilityChecklistWitnessItemsItems0 struct {

	// critical
	// Required: true
	Critical []string `json:"critical"`

	// info
	// Required: true
	Info []string `json:"info"`

	// key
	// Required: true
	Key *string `json:"key"`

	// labels
	// Required: true
	Labels interface{} `json:"labels"`

	// notice
	// Required: true
	Notice []string `json:"notice"`

	// status
	// Required: true
	Status *MetroCheckStatusEnum `json:"status"`
}

// Validate validates this cluster metro availability checklist witness items items0
func (m *ClusterMetroAvailabilityChecklistWitnessItemsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCritical(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateKey(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLabels(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNotice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterMetroAvailabilityChecklistWitnessItemsItems0) validateCritical(formats strfmt.Registry) error {

	if err := validate.Required("critical", "body", m.Critical); err != nil {
		return err
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistWitnessItemsItems0) validateInfo(formats strfmt.Registry) error {

	if err := validate.Required("info", "body", m.Info); err != nil {
		return err
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistWitnessItemsItems0) validateKey(formats strfmt.Registry) error {

	if err := validate.Required("key", "body", m.Key); err != nil {
		return err
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistWitnessItemsItems0) validateLabels(formats strfmt.Registry) error {

	if m.Labels == nil {
		return errors.Required("labels", "body", nil)
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistWitnessItemsItems0) validateNotice(formats strfmt.Registry) error {

	if err := validate.Required("notice", "body", m.Notice); err != nil {
		return err
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistWitnessItemsItems0) validateStatus(formats strfmt.Registry) error {

	if err := validate.Required("status", "body", m.Status); err != nil {
		return err
	}

	if err := validate.Required("status", "body", m.Status); err != nil {
		return err
	}

	if m.Status != nil {
		if err := m.Status.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("status")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster metro availability checklist witness items items0 based on the context it is used
func (m *ClusterMetroAvailabilityChecklistWitnessItemsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterMetroAvailabilityChecklistWitnessItemsItems0) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if m.Status != nil {
		if err := m.Status.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("status")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterMetroAvailabilityChecklistWitnessItemsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterMetroAvailabilityChecklistWitnessItemsItems0) UnmarshalBinary(b []byte) error {
	var res ClusterMetroAvailabilityChecklistWitnessItemsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterMetroAvailabilityChecklistZoneAndZone cluster metro availability checklist zone and zone
//
// swagger:model ClusterMetroAvailabilityChecklistZoneAndZone
type ClusterMetroAvailabilityChecklistZoneAndZone struct {

	// critical
	// Required: true
	Critical *float64 `json:"critical"`

	// info
	// Required: true
	Info *float64 `json:"info"`

	// items
	// Required: true
	Items []*ClusterMetroAvailabilityChecklistZoneAndZoneItemsItems0 `json:"items"`

	// notice
	// Required: true
	Notice *float64 `json:"notice"`

	// status
	// Required: true
	Status *MetroCheckStatusEnum `json:"status"`
}

// Validate validates this cluster metro availability checklist zone and zone
func (m *ClusterMetroAvailabilityChecklistZoneAndZone) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCritical(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateItems(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNotice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterMetroAvailabilityChecklistZoneAndZone) validateCritical(formats strfmt.Registry) error {

	if err := validate.Required("metro_availability_checklist"+"."+"zoneAndZone"+"."+"critical", "body", m.Critical); err != nil {
		return err
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistZoneAndZone) validateInfo(formats strfmt.Registry) error {

	if err := validate.Required("metro_availability_checklist"+"."+"zoneAndZone"+"."+"info", "body", m.Info); err != nil {
		return err
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistZoneAndZone) validateItems(formats strfmt.Registry) error {

	if err := validate.Required("metro_availability_checklist"+"."+"zoneAndZone"+"."+"items", "body", m.Items); err != nil {
		return err
	}

	for i := 0; i < len(m.Items); i++ {
		if swag.IsZero(m.Items[i]) { // not required
			continue
		}

		if m.Items[i] != nil {
			if err := m.Items[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("metro_availability_checklist" + "." + "zoneAndZone" + "." + "items" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistZoneAndZone) validateNotice(formats strfmt.Registry) error {

	if err := validate.Required("metro_availability_checklist"+"."+"zoneAndZone"+"."+"notice", "body", m.Notice); err != nil {
		return err
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistZoneAndZone) validateStatus(formats strfmt.Registry) error {

	if err := validate.Required("metro_availability_checklist"+"."+"zoneAndZone"+"."+"status", "body", m.Status); err != nil {
		return err
	}

	if err := validate.Required("metro_availability_checklist"+"."+"zoneAndZone"+"."+"status", "body", m.Status); err != nil {
		return err
	}

	if m.Status != nil {
		if err := m.Status.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metro_availability_checklist" + "." + "zoneAndZone" + "." + "status")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster metro availability checklist zone and zone based on the context it is used
func (m *ClusterMetroAvailabilityChecklistZoneAndZone) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateItems(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterMetroAvailabilityChecklistZoneAndZone) contextValidateItems(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Items); i++ {

		if m.Items[i] != nil {
			if err := m.Items[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("metro_availability_checklist" + "." + "zoneAndZone" + "." + "items" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistZoneAndZone) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if m.Status != nil {
		if err := m.Status.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metro_availability_checklist" + "." + "zoneAndZone" + "." + "status")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterMetroAvailabilityChecklistZoneAndZone) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterMetroAvailabilityChecklistZoneAndZone) UnmarshalBinary(b []byte) error {
	var res ClusterMetroAvailabilityChecklistZoneAndZone
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterMetroAvailabilityChecklistZoneAndZoneItemsItems0 cluster metro availability checklist zone and zone items items0
//
// swagger:model ClusterMetroAvailabilityChecklistZoneAndZoneItemsItems0
type ClusterMetroAvailabilityChecklistZoneAndZoneItemsItems0 struct {

	// critical
	// Required: true
	Critical []string `json:"critical"`

	// info
	// Required: true
	Info []string `json:"info"`

	// key
	// Required: true
	Key *string `json:"key"`

	// labels
	// Required: true
	Labels interface{} `json:"labels"`

	// notice
	// Required: true
	Notice []string `json:"notice"`

	// status
	// Required: true
	Status *MetroCheckStatusEnum `json:"status"`
}

// Validate validates this cluster metro availability checklist zone and zone items items0
func (m *ClusterMetroAvailabilityChecklistZoneAndZoneItemsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCritical(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateKey(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLabels(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNotice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterMetroAvailabilityChecklistZoneAndZoneItemsItems0) validateCritical(formats strfmt.Registry) error {

	if err := validate.Required("critical", "body", m.Critical); err != nil {
		return err
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistZoneAndZoneItemsItems0) validateInfo(formats strfmt.Registry) error {

	if err := validate.Required("info", "body", m.Info); err != nil {
		return err
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistZoneAndZoneItemsItems0) validateKey(formats strfmt.Registry) error {

	if err := validate.Required("key", "body", m.Key); err != nil {
		return err
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistZoneAndZoneItemsItems0) validateLabels(formats strfmt.Registry) error {

	if m.Labels == nil {
		return errors.Required("labels", "body", nil)
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistZoneAndZoneItemsItems0) validateNotice(formats strfmt.Registry) error {

	if err := validate.Required("notice", "body", m.Notice); err != nil {
		return err
	}

	return nil
}

func (m *ClusterMetroAvailabilityChecklistZoneAndZoneItemsItems0) validateStatus(formats strfmt.Registry) error {

	if err := validate.Required("status", "body", m.Status); err != nil {
		return err
	}

	if err := validate.Required("status", "body", m.Status); err != nil {
		return err
	}

	if m.Status != nil {
		if err := m.Status.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("status")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster metro availability checklist zone and zone items items0 based on the context it is used
func (m *ClusterMetroAvailabilityChecklistZoneAndZoneItemsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterMetroAvailabilityChecklistZoneAndZoneItemsItems0) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if m.Status != nil {
		if err := m.Status.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("status")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterMetroAvailabilityChecklistZoneAndZoneItemsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterMetroAvailabilityChecklistZoneAndZoneItemsItems0) UnmarshalBinary(b []byte) error {
	var res ClusterMetroAvailabilityChecklistZoneAndZoneItemsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterSettings cluster settings
//
// swagger:model ClusterSettings
type ClusterSettings struct {

	// id
	// Required: true
	ID *string `json:"id"`
}

// Validate validates this cluster settings
func (m *ClusterSettings) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterSettings) validateID(formats strfmt.Registry) error {

	if err := validate.Required("settings"+"."+"id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this cluster settings based on context it is used
func (m *ClusterSettings) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ClusterSettings) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterSettings) UnmarshalBinary(b []byte) error {
	var res ClusterSettings
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterVMFoldersItems0 cluster VM folders items0
//
// swagger:model ClusterVMFoldersItems0
type ClusterVMFoldersItems0 struct {

	// id
	// Required: true
	ID *string `json:"id"`

	// name
	// Required: true
	Name *string `json:"name"`
}

// Validate validates this cluster VM folders items0
func (m *ClusterVMFoldersItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterVMFoldersItems0) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

func (m *ClusterVMFoldersItems0) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this cluster VM folders items0 based on context it is used
func (m *ClusterVMFoldersItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ClusterVMFoldersItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterVMFoldersItems0) UnmarshalBinary(b []byte) error {
	var res ClusterVMFoldersItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterVMTemplatesItems0 cluster VM templates items0
//
// swagger:model ClusterVMTemplatesItems0
type ClusterVMTemplatesItems0 struct {

	// id
	// Required: true
	ID *string `json:"id"`

	// name
	// Required: true
	Name *string `json:"name"`
}

// Validate validates this cluster VM templates items0
func (m *ClusterVMTemplatesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterVMTemplatesItems0) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

func (m *ClusterVMTemplatesItems0) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this cluster VM templates items0 based on context it is used
func (m *ClusterVMTemplatesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ClusterVMTemplatesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterVMTemplatesItems0) UnmarshalBinary(b []byte) error {
	var res ClusterVMTemplatesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterVcenterAccount cluster vcenter account
//
// swagger:model ClusterVcenterAccount
type ClusterVcenterAccount struct {

	// id
	// Required: true
	ID *string `json:"id"`
}

// Validate validates this cluster vcenter account
func (m *ClusterVcenterAccount) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterVcenterAccount) validateID(formats strfmt.Registry) error {

	if err := validate.Required("vcenterAccount"+"."+"id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this cluster vcenter account based on context it is used
func (m *ClusterVcenterAccount) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ClusterVcenterAccount) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterVcenterAccount) UnmarshalBinary(b []byte) error {
	var res ClusterVcenterAccount
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterVdsesItems0 cluster vdses items0
//
// swagger:model ClusterVdsesItems0
type ClusterVdsesItems0 struct {

	// id
	// Required: true
	ID *string `json:"id"`

	// name
	// Required: true
	Name *string `json:"name"`
}

// Validate validates this cluster vdses items0
func (m *ClusterVdsesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterVdsesItems0) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

func (m *ClusterVdsesItems0) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this cluster vdses items0 based on context it is used
func (m *ClusterVdsesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ClusterVdsesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterVdsesItems0) UnmarshalBinary(b []byte) error {
	var res ClusterVdsesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterVmsItems0 cluster vms items0
//
// swagger:model ClusterVmsItems0
type ClusterVmsItems0 struct {

	// id
	// Required: true
	ID *string `json:"id"`

	// name
	// Required: true
	Name *string `json:"name"`
}

// Validate validates this cluster vms items0
func (m *ClusterVmsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterVmsItems0) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

func (m *ClusterVmsItems0) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this cluster vms items0 based on context it is used
func (m *ClusterVmsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ClusterVmsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterVmsItems0) UnmarshalBinary(b []byte) error {
	var res ClusterVmsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterWitness cluster witness
//
// swagger:model ClusterWitness
type ClusterWitness struct {

	// id
	// Required: true
	ID *string `json:"id"`

	// name
	// Required: true
	Name *string `json:"name"`
}

// Validate validates this cluster witness
func (m *ClusterWitness) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterWitness) validateID(formats strfmt.Registry) error {

	if err := validate.Required("witness"+"."+"id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

func (m *ClusterWitness) validateName(formats strfmt.Registry) error {

	if err := validate.Required("witness"+"."+"name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this cluster witness based on context it is used
func (m *ClusterWitness) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ClusterWitness) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterWitness) UnmarshalBinary(b []byte) error {
	var res ClusterWitness
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ClusterZonesItems0 cluster zones items0
//
// swagger:model ClusterZonesItems0
type ClusterZonesItems0 struct {

	// id
	// Required: true
	ID *string `json:"id"`
}

// Validate validates this cluster zones items0
func (m *ClusterZonesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterZonesItems0) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this cluster zones items0 based on context it is used
func (m *ClusterZonesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ClusterZonesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterZonesItems0) UnmarshalBinary(b []byte) error {
	var res ClusterZonesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
